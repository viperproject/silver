// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.
//
// Copyright (c) 2011-2022 ETH Zurich.

package viper.silver.plugin.standard.adt.encoding


import viper.silver.ast.Program

import scala.collection.mutable


/**
  * A simple interface to transform/extend a program.
  * Contains utility functions to avoid name conflicts (e.g. when adding a new domain functions to a domain)
  */
trait AdtNameManager {

  /**
    * This field holds the original program
    */
  val program: Program

  /**
    * This field hold a set that contains all global names of the original program
    */
  private val usedNames: mutable.Set[String] = collection.mutable.Set(program.transitiveScopedDecls.map(_.name): _*)

  /**
    * This field stores the mappings generated by getName(...)
    */
  private val adtNameMappings: mutable.Map[String, String] = mutable.Map()

  /**
    * Following helper methods return predefined names/identifiers for the contains relation for ADTs.
    * Note that the first two names are fixed by resources/adt/contains.vpr
    */
  def getContainsDomainName: String = "ContainsDomain"

  def getContainsFunctionName: String = "contains"

  def getWellFoundedDomainName(typeName: String): String = typeName + "WellFoundedOrder"
  def getWellFoundedOrderDeclarationDomainName : String = "WellFoundedOrder"
  def getDecreasesFunctionName: String = "decreasing"
  def getBoundedFunctionName: String = "bounded"

  def getContainsTransitivityDomain: String = getName("ContainsTransitivityDomain")

  /**
    * This method returns the name of the destructor given the name of the ADT and the name of a constructor argument
    *
    * @param adtName  The name of the ADT the destructor belongs to
    * @param argument The name of a constructor argument for which we want the corresponding destructor
    * @return The name of the queried constructor
    */
  def getDestructorName(adtName: String, argument: String): String = getName(s"get_${adtName}_$argument")

  /**
    * This method will return the name of the tag function given the ADT name
    *
    * @param adtName The name of the ADT for which we want the name of the tag function
    * @return The name of the tag function
    */
  def getTagName(adtName: String): String = getName(s"${adtName}_tag")

  /**
    * This method returns an unique name and adds the new generated name to the adtNameMappings. If the method is
    * called again with the same argument, the corresponding unique name is looked ap in adtNameMappings and returned.
    *
    * @param trueName A potential name to be unique
    * @return
    */
  private def getName(trueName: String): String = {
    if (!adtNameMappings.contains(trueName)) {
      val newName = if (containsName(trueName)) uniqueName(trueName) else trueName
      adtNameMappings.addOne((trueName, newName))
    }
    adtNameMappings(trueName)
  }

  /**
    * Creates a unique name for the program and adds it to the names already used in the program.
    *
    * @param name which is wanted
    * @return a name which is unique in the program
    */
  private def uniqueName(name: String): String = {
    var i = 1
    var newName = name
    while (containsName(newName)) {
      newName = name + i
      i += 1
    }
    usedNames.add(newName)
    newName
  }

  /**
    * Checks if a name already occurs in the program.
    *
    * @param name to be checked
    * @return true iff the name is used in the program.
    */
  private def containsName(name: String): Boolean = {
    usedNames.contains(name)
  }

}
