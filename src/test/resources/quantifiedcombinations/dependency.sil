field f:Int
  field g:Int
  field vals:Seq[Int]
  
  predicate pred(x:Ref) {
      acc(x.f)
  }
  
  function get_val(xs:Seq[Ref], i:Int):Ref
  {
      xs[i]
  }
  
  method m1(xs:Seq[Ref])
  requires forall x:Ref :: x in xs ==> acc(x.f) && x.f > 0
  ensures forall x:Ref :: x in xs ==> acc(x.f) && x.f > 0
  {}
  
  
  method m2(xs:Seq[Ref])
  requires forall x:Ref :: x in xs ==> x.f > 0 && acc(x.f)
  ensures forall x:Ref :: x in xs ==> x.f > 0 && acc(x.f)
  {}
  
  
  method m3(xs:Seq[Ref], y:Ref)
  requires forall x:Ref :: x in xs ==> acc(pred(x))
  requires y in xs
  //ensures forall x:Ref :: x in xs ==> acc(pred(x)) && unfolding pred(x) in true
  ensures forall x:Ref :: x in xs ==> (unfolding pred(x) in true) && acc(pred(x))
  {}
  
  method m4(xs:Seq[Ref])
  requires forall x:Ref :: x in xs ==> acc(x.f) && acc(pred2(x.f))
  ensures forall x:Ref :: x in xs ==> acc(x.f) && acc(pred2(x.f))
  {}
  