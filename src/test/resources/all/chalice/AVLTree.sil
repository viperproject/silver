// Any copyright is dedicated to the Public Domain.
// http://creativecommons.org/publicdomain/zero/1.0/

//:: IgnoreFile(/carbon/issue/18/)
//:: IgnoreFile(/silicon/issue/90/)
domain GlobalKPermission {
  
  unique function globalK$(): Perm
  
  axiom globalKReadOnly {
    (globalK$() > none) && (write > globalK$())
  }
}

field old$methodPermission: Perm

field joinable$: Bool

field AVLTreeroot$: Ref

field AVLTreekeys$: Seq[Int]

field AVLTreeNodekey$: Int

field AVLTreeNodeheight$: Int

field AVLTreeNodeleft$: Ref

field AVLTreeNoderight$: Ref

field AVLTreeNodekeys$: Seq[Int]

field AVLTreeNodebalanceFactor$: Int

field par$AVLTreeinit$this$_2: Ref

field par$AVLTreeinit$k$: Perm

field old$AVLTreeinsert$0: Seq[Int]

field old$AVLTreeinsert$1: Seq[Int]

field par$AVLTreeinsert$this$_3: Ref

field par$AVLTreeinsert$k$_1: Perm

field par$AVLTreeinsert$k: Int

field old$AVLTreeremove$0: Seq[Int]

field old$AVLTreeremove$1: Seq[Int]

field par$AVLTreeremove$this$_4: Ref

field par$AVLTreeremove$k$_2: Perm

field par$AVLTreeremove$k: Int

field par$AVLTreehas$this$_5: Ref

field par$AVLTreehas$k$_3: Perm

field par$AVLTreehas$k: Int

field par$AVLTreeNodeinit$this$_8: Ref

field par$AVLTreeNodeinit$k$_4: Perm

field par$AVLTreeNodeinit$k: Int

field old$AVLTreeNodeinsert$0: Seq[Int]

field old$AVLTreeNodeinsert$1: Seq[Int]

field old$AVLTreeNodeinsert$2: Seq[Int]

field old$AVLTreeNodeinsert$3: Seq[Int]

field old$AVLTreeNodeinsert$4: Seq[Int]

field old$AVLTreeNodeinsert$5: Seq[Int]

field old$AVLTreeNodeinsert$6: Int

field old$AVLTreeNodeinsert$7: Int

field old$AVLTreeNodeinsert$8: Seq[Int]

field old$AVLTreeNodeinsert$9: Int

field par$AVLTreeNodeinsert$this$_9: Ref

field par$AVLTreeNodeinsert$k$_5: Perm

field par$AVLTreeNodeinsert$k: Int

field old$AVLTreeNoderemove$0: Seq[Int]

field old$AVLTreeNoderemove$1: Seq[Int]

field old$AVLTreeNoderemove$2: Seq[Int]

field old$AVLTreeNoderemove$3: Seq[Int]

field old$AVLTreeNoderemove$4: Seq[Int]

field old$AVLTreeNoderemove$5: Seq[Int]

field old$AVLTreeNoderemove$6: Seq[Int]

field old$AVLTreeNoderemove$7: Seq[Int]

field old$AVLTreeNoderemove$8: Seq[Int]

field old$AVLTreeNoderemove$9: Int

field old$AVLTreeNoderemove$10: Int

field old$AVLTreeNoderemove$11: Int

field old$AVLTreeNoderemove$12: Seq[Int]

field old$AVLTreeNoderemove$13: Int

field par$AVLTreeNoderemove$this$_10: Ref

field par$AVLTreeNoderemove$k$_6: Perm

field par$AVLTreeNoderemove$k: Int

field old$AVLTreeNodepruneMax$0: Int

field old$AVLTreeNodepruneMax$1: Int

field old$AVLTreeNodepruneMax$2: Seq[Int]

field old$AVLTreeNodepruneMax$3: Int

field old$AVLTreeNodepruneMax$4: Int

field old$AVLTreeNodepruneMax$5: Int

field old$AVLTreeNodepruneMax$6: Int

field old$AVLTreeNodepruneMax$7: Seq[Int]

field par$AVLTreeNodepruneMax$this$_11: Ref

field par$AVLTreeNodepruneMax$k$_7: Perm

field old$AVLTreeNodepruneMin$0: Int

field old$AVLTreeNodepruneMin$1: Int

field old$AVLTreeNodepruneMin$2: Seq[Int]

field old$AVLTreeNodepruneMin$3: Int

field old$AVLTreeNodepruneMin$4: Int

field old$AVLTreeNodepruneMin$5: Int

field old$AVLTreeNodepruneMin$6: Int

field old$AVLTreeNodepruneMin$7: Seq[Int]

field par$AVLTreeNodepruneMin$this$_12: Ref

field par$AVLTreeNodepruneMin$k$_8: Perm

field par$AVLTreeNodehas$this$_13: Ref

field par$AVLTreeNodehas$k$_9: Perm

field par$AVLTreeNodehas$k: Int

field par$AVLTreeNodegetBalanceFactor$this$_14: Ref

field par$AVLTreeNodegetBalanceFactor$k$_10: Perm

field par$AVLTreeNodegetBalanceFactorI$this$_15: Ref

field par$AVLTreeNodegetBalanceFactorI$k$_11: Perm

field old$AVLTreeNodeclose$0: Ref

field old$AVLTreeNodeclose$1: Seq[Int]

field old$AVLTreeNodeclose$2: Int

field old$AVLTreeNodeclose$3: Ref

field old$AVLTreeNodeclose$4: Seq[Int]

field old$AVLTreeNodeclose$5: Ref

field old$AVLTreeNodeclose$6: Int

field old$AVLTreeNodeclose$7: Ref

field old$AVLTreeNodeclose$8: Int

field old$AVLTreeNodeclose$9: Ref

field old$AVLTreeNodeclose$10: Int

field old$AVLTreeNodeclose$11: Ref

field old$AVLTreeNodeclose$12: Int

field old$AVLTreeNodeclose$13: Ref

field old$AVLTreeNodeclose$14: Int

field old$AVLTreeNodeclose$15: Ref

field old$AVLTreeNodeclose$16: Int

field par$AVLTreeNodeclose$this$_16: Ref

field par$AVLTreeNodeclose$k$_12: Perm

field old$AVLTreeNoderebalanceLeft$0: Int

field old$AVLTreeNoderebalanceLeft$1: Int

field old$AVLTreeNoderebalanceLeft$2: Seq[Int]

field old$AVLTreeNoderebalanceLeft$3: Int

field old$AVLTreeNoderebalanceLeft$4: Ref

field old$AVLTreeNoderebalanceLeft$5: Seq[Int]

field par$AVLTreeNoderebalanceLeft$this$_17: Ref

field par$AVLTreeNoderebalanceLeft$k$_13: Perm

field old$AVLTreeNoderebalanceRL$0: Int

field old$AVLTreeNoderebalanceRL$1: Seq[Int]

field old$AVLTreeNoderebalanceRL$2: Int

field old$AVLTreeNoderebalanceRL$3: Ref

field old$AVLTreeNoderebalanceRL$4: Seq[Int]

field par$AVLTreeNoderebalanceRL$this$_18: Ref

field par$AVLTreeNoderebalanceRL$k$_14: Perm

field old$AVLTreeNoderebalanceRR$0: Int

field old$AVLTreeNoderebalanceRR$1: Int

field old$AVLTreeNoderebalanceRR$2: Seq[Int]

field old$AVLTreeNoderebalanceRR$3: Int

field old$AVLTreeNoderebalanceRR$4: Ref

field old$AVLTreeNoderebalanceRR$5: Seq[Int]

field par$AVLTreeNoderebalanceRR$this$_19: Ref

field par$AVLTreeNoderebalanceRR$k$_15: Perm

field old$AVLTreeNoderebalanceRight$0: Int

field old$AVLTreeNoderebalanceRight$1: Int

field old$AVLTreeNoderebalanceRight$2: Ref

field old$AVLTreeNoderebalanceRight$3: Seq[Int]

field old$AVLTreeNoderebalanceRight$4: Int

field old$AVLTreeNoderebalanceRight$5: Seq[Int]

field par$AVLTreeNoderebalanceRight$this$_20: Ref

field par$AVLTreeNoderebalanceRight$k$_16: Perm

field old$AVLTreeNoderebalanceLR$0: Int

field old$AVLTreeNoderebalanceLR$1: Ref

field old$AVLTreeNoderebalanceLR$2: Seq[Int]

field old$AVLTreeNoderebalanceLR$3: Int

field old$AVLTreeNoderebalanceLR$4: Seq[Int]

field par$AVLTreeNoderebalanceLR$this$_21: Ref

field par$AVLTreeNoderebalanceLR$k$_17: Perm

field old$AVLTreeNoderebalanceLL$0: Int

field old$AVLTreeNoderebalanceLL$1: Int

field old$AVLTreeNoderebalanceLL$2: Ref

field old$AVLTreeNoderebalanceLL$3: Seq[Int]

field old$AVLTreeNoderebalanceLL$4: Int

field old$AVLTreeNoderebalanceLL$5: Seq[Int]

field par$AVLTreeNoderebalanceLL$this$_22: Ref

field par$AVLTreeNoderebalanceLL$k$_18: Perm

predicate AVLTree$MonitorInvariant(this$: Ref) {
  true
}

predicate AVLTreevalid$(this$_1: Ref) {

  acc(this$_1.AVLTreeroot$, 100 / 100) && acc(this$_1.AVLTreekeys$, 50 / 100) && ((this$_1.AVLTreeroot$ != null) ==> acc(AVLTreeNodevalid$(this$_1.AVLTreeroot$), write)) && ((this$_1.AVLTreeroot$ != null) ==> acc(this$_1.AVLTreeroot$.AVLTreeNodeheight$, 50 / 100)) && ((this$_1.AVLTreeroot$ != null) ==> acc(this$_1.AVLTreeroot$.AVLTreeNodekeys$, 50 / 100)) && ((this$_1.AVLTreeroot$ != null) ==> acc(this$_1.AVLTreeroot$.AVLTreeNodebalanceFactor$, 50 / 100)) && ((this$_1.AVLTreeroot$ != null) ==> (this$_1.AVLTreekeys$ == this$_1.AVLTreeroot$.AVLTreeNodekeys$)) && ((this$_1.AVLTreeroot$ == null) ==> (this$_1.AVLTreekeys$ == Seq[Int]()))
}

predicate AVLTreeNode$MonitorInvariant(this$_6: Ref) {
  true
}

predicate AVLTreeNodevalid$(this$_7: Ref) {
  acc(this$_7.AVLTreeNodekey$, 100 / 100) && 
  acc(this$_7.AVLTreeNodeheight$, 50 / 100) && 
  acc(this$_7.AVLTreeNodeleft$, 100 / 100) &&
  acc(this$_7.AVLTreeNoderight$, 100 / 100) &&
  acc(this$_7.AVLTreeNodekeys$, 50 / 100) && 
  acc(this$_7.AVLTreeNodebalanceFactor$, 50 / 100) &&
  ((this$_7.AVLTreeNodeleft$ != null) ==> acc(AVLTreeNodevalid$(this$_7.AVLTreeNodeleft$), write)) &&
  ((this$_7.AVLTreeNodeleft$ != null) ==> acc(this$_7.AVLTreeNodeleft$.AVLTreeNodeheight$, 50 / 100)) &&
  ((this$_7.AVLTreeNodeleft$ != null) ==> acc(this$_7.AVLTreeNodeleft$.AVLTreeNodekeys$, 50 / 100)) && 
  ((this$_7.AVLTreeNodeleft$ != null) ==> acc(this$_7.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$, 50 / 100)) &&
  ((this$_7.AVLTreeNodeleft$ != null) ==> (forall lk: Int :: true && lk in this$_7.AVLTreeNodeleft$.AVLTreeNodekeys$ ==> (lk < this$_7.AVLTreeNodekey$))) &&
  ((this$_7.AVLTreeNodeleft$ != null) ==> (this$_7.AVLTreeNodeleft$.AVLTreeNodeheight$ > 0)) &&
  ((this$_7.AVLTreeNoderight$ != null) ==> acc(AVLTreeNodevalid$(this$_7.AVLTreeNoderight$), write)) &&
  ((this$_7.AVLTreeNoderight$ != null) ==> acc(this$_7.AVLTreeNoderight$.AVLTreeNodeheight$, 50 / 100)) && 
  ((this$_7.AVLTreeNoderight$ != null) ==> acc(this$_7.AVLTreeNoderight$.AVLTreeNodekeys$, 50 / 100)) && 
  ((this$_7.AVLTreeNoderight$ != null) ==> acc(this$_7.AVLTreeNoderight$.AVLTreeNodebalanceFactor$, 50 / 100)) &&
  ((this$_7.AVLTreeNoderight$ != null) ==> (forall rk: Int :: true && rk in this$_7.AVLTreeNoderight$.AVLTreeNodekeys$ ==> (this$_7.AVLTreeNodekey$ < rk))) &&
  ((this$_7.AVLTreeNoderight$ != null) ==> (this$_7.AVLTreeNoderight$.AVLTreeNodeheight$ > 0)) &&
  (this$_7.AVLTreeNodekeys$ == (this$_7.AVLTreeNodeleft$ == null ? Seq[Int]() : this$_7.AVLTreeNodeleft$.AVLTreeNodekeys$) ++ Seq(this$_7.AVLTreeNodekey$) ++ (this$_7.AVLTreeNoderight$ == null ? Seq[Int]() : this$_7.AVLTreeNoderight$.AVLTreeNodekeys$)) &&
  this$_7.AVLTreeNodekey$ in this$_7.AVLTreeNodekeys$ && 
  (forall kk: Int :: true ==> (
	kk in this$_7.AVLTreeNodekeys$ <==> (this$_7.AVLTreeNodeleft$ != null) && 
	kk in this$_7.AVLTreeNodeleft$.AVLTreeNodekeys$ || 
	(this$_7.AVLTreeNoderight$ != null) && 
	kk in this$_7.AVLTreeNoderight$.AVLTreeNodekeys$ || 
	(kk == this$_7.AVLTreeNodekey$))
	) &&
  (this$_7.AVLTreeNodeheight$ == ((this$_7.AVLTreeNodeleft$ == null ? 0 : this$_7.AVLTreeNodeleft$.AVLTreeNodeheight$) > (this$_7.AVLTreeNoderight$ == null ? 0 : this$_7.AVLTreeNoderight$.AVLTreeNodeheight$) ? (this$_7.AVLTreeNodeleft$ == null ? 0 : this$_7.AVLTreeNodeleft$.AVLTreeNodeheight$) + 1 : (this$_7.AVLTreeNoderight$ == null ? 0 : this$_7.AVLTreeNoderight$.AVLTreeNodeheight$) + 1)) && 
  (this$_7.AVLTreeNodebalanceFactor$ == (this$_7.AVLTreeNodeleft$ == null ? 0 : this$_7.AVLTreeNodeleft$.AVLTreeNodeheight$) - (this$_7.AVLTreeNoderight$ == null ? 0 : this$_7.AVLTreeNoderight$.AVLTreeNodeheight$)) &&
  (this$_7.AVLTreeNodebalanceFactor$ <= 1) &&
  (this$_7.AVLTreeNodebalanceFactor$ >= 0 - 1) && (this$_7.AVLTreeNodeheight$ > 0)
}

method AVLTreeinit$(this$_2: Ref, k$: Perm)
  requires this$_2 != null
  requires k$ > none
  requires write > k$
  requires acc(this$_2.AVLTreeroot$, 100 / 100)
  requires acc(this$_2.AVLTreekeys$, 100 / 100)
  ensures acc(AVLTreevalid$(this$_2), write)
  ensures acc(this$_2.AVLTreekeys$, 50 / 100)
  ensures this$_2.AVLTreekeys$ == Seq[Int]()
{
  var n$: Ref
  var a$: Ref
  var b$: Set[Ref]
  var c$: Set[Ref]
  this$_2.AVLTreeroot$ := null
  this$_2.AVLTreekeys$ := Seq[Int]()
  fold acc(AVLTreevalid$(this$_2), write)
}

method AVLTreeinsert$(this$_3: Ref, k$_1: Perm, k: Int)
  requires this$_3 != null
  requires k$_1 > none
  requires write > k$_1
  requires acc(AVLTreevalid$(this$_3), write)
  requires acc(this$_3.AVLTreekeys$, 50 / 100)
  ensures acc(AVLTreevalid$(this$_3), write)
  ensures acc(this$_3.AVLTreekeys$, 50 / 100)
  ensures k in this$_3.AVLTreekeys$
  ensures (forall j: Int :: true && j in old(this$_3.AVLTreekeys$) ==> j in this$_3.AVLTreekeys$)
  ensures (forall j: Int :: true && j in this$_3.AVLTreekeys$ ==> j in old(this$_3.AVLTreekeys$) || (j == k))
{
  var n$_1: Ref
  var a$_1: Ref
  var b$_1: Set[Ref]
  var c$_1: Set[Ref]
  var n: Ref
  var newK$_35: Perm
  var newK$_36: Perm
  var r: Ref
  unfold acc(AVLTreevalid$(this$_3), write)
  if (this$_3.AVLTreeroot$ == null) {
    n := new(old$methodPermission, joinable$, AVLTreeroot$, AVLTreekeys$, AVLTreeNodekey$, AVLTreeNodeheight$, AVLTreeNodeleft$, AVLTreeNoderight$, AVLTreeNodekeys$, AVLTreeNodebalanceFactor$, par$AVLTreeinit$this$_2, par$AVLTreeinit$k$, old$AVLTreeinsert$0, old$AVLTreeinsert$1, par$AVLTreeinsert$this$_3, par$AVLTreeinsert$k$_1, par$AVLTreeinsert$k, old$AVLTreeremove$0, old$AVLTreeremove$1, par$AVLTreeremove$this$_4, par$AVLTreeremove$k$_2, par$AVLTreeremove$k, par$AVLTreehas$this$_5, par$AVLTreehas$k$_3, par$AVLTreehas$k, par$AVLTreeNodeinit$this$_8, par$AVLTreeNodeinit$k$_4, par$AVLTreeNodeinit$k, old$AVLTreeNodeinsert$0, old$AVLTreeNodeinsert$1, old$AVLTreeNodeinsert$2, old$AVLTreeNodeinsert$3, old$AVLTreeNodeinsert$4, old$AVLTreeNodeinsert$5, old$AVLTreeNodeinsert$6, old$AVLTreeNodeinsert$7, old$AVLTreeNodeinsert$8, old$AVLTreeNodeinsert$9, par$AVLTreeNodeinsert$this$_9, par$AVLTreeNodeinsert$k$_5, par$AVLTreeNodeinsert$k, old$AVLTreeNoderemove$0, old$AVLTreeNoderemove$1, old$AVLTreeNoderemove$2, old$AVLTreeNoderemove$3, old$AVLTreeNoderemove$4, old$AVLTreeNoderemove$5, old$AVLTreeNoderemove$6, old$AVLTreeNoderemove$7, old$AVLTreeNoderemove$8, old$AVLTreeNoderemove$9, old$AVLTreeNoderemove$10, old$AVLTreeNoderemove$11, old$AVLTreeNoderemove$12, old$AVLTreeNoderemove$13, par$AVLTreeNoderemove$this$_10, par$AVLTreeNoderemove$k$_6, par$AVLTreeNoderemove$k, old$AVLTreeNodepruneMax$0, old$AVLTreeNodepruneMax$1, old$AVLTreeNodepruneMax$2, old$AVLTreeNodepruneMax$3, old$AVLTreeNodepruneMax$4, old$AVLTreeNodepruneMax$5, old$AVLTreeNodepruneMax$6, old$AVLTreeNodepruneMax$7, par$AVLTreeNodepruneMax$this$_11, par$AVLTreeNodepruneMax$k$_7, old$AVLTreeNodepruneMin$0, old$AVLTreeNodepruneMin$1, old$AVLTreeNodepruneMin$2, old$AVLTreeNodepruneMin$3, old$AVLTreeNodepruneMin$4, old$AVLTreeNodepruneMin$5, old$AVLTreeNodepruneMin$6, old$AVLTreeNodepruneMin$7, par$AVLTreeNodepruneMin$this$_12, par$AVLTreeNodepruneMin$k$_8, par$AVLTreeNodehas$this$_13, par$AVLTreeNodehas$k$_9, par$AVLTreeNodehas$k, par$AVLTreeNodegetBalanceFactor$this$_14, par$AVLTreeNodegetBalanceFactor$k$_10, par$AVLTreeNodegetBalanceFactorI$this$_15, par$AVLTreeNodegetBalanceFactorI$k$_11, old$AVLTreeNodeclose$0, old$AVLTreeNodeclose$1, old$AVLTreeNodeclose$2, old$AVLTreeNodeclose$3, old$AVLTreeNodeclose$4, old$AVLTreeNodeclose$5, old$AVLTreeNodeclose$6, old$AVLTreeNodeclose$7, old$AVLTreeNodeclose$8, old$AVLTreeNodeclose$9, old$AVLTreeNodeclose$10, old$AVLTreeNodeclose$11, old$AVLTreeNodeclose$12, old$AVLTreeNodeclose$13, old$AVLTreeNodeclose$14, old$AVLTreeNodeclose$15, old$AVLTreeNodeclose$16, par$AVLTreeNodeclose$this$_16, par$AVLTreeNodeclose$k$_12, old$AVLTreeNoderebalanceLeft$0, old$AVLTreeNoderebalanceLeft$1, old$AVLTreeNoderebalanceLeft$2, old$AVLTreeNoderebalanceLeft$3, old$AVLTreeNoderebalanceLeft$4, old$AVLTreeNoderebalanceLeft$5, par$AVLTreeNoderebalanceLeft$this$_17, par$AVLTreeNoderebalanceLeft$k$_13, old$AVLTreeNoderebalanceRL$0, old$AVLTreeNoderebalanceRL$1, old$AVLTreeNoderebalanceRL$2, old$AVLTreeNoderebalanceRL$3, old$AVLTreeNoderebalanceRL$4, par$AVLTreeNoderebalanceRL$this$_18, par$AVLTreeNoderebalanceRL$k$_14, old$AVLTreeNoderebalanceRR$0, old$AVLTreeNoderebalanceRR$1, old$AVLTreeNoderebalanceRR$2, old$AVLTreeNoderebalanceRR$3, old$AVLTreeNoderebalanceRR$4, old$AVLTreeNoderebalanceRR$5, par$AVLTreeNoderebalanceRR$this$_19, par$AVLTreeNoderebalanceRR$k$_15, old$AVLTreeNoderebalanceRight$0, old$AVLTreeNoderebalanceRight$1, old$AVLTreeNoderebalanceRight$2, old$AVLTreeNoderebalanceRight$3, old$AVLTreeNoderebalanceRight$4, old$AVLTreeNoderebalanceRight$5, par$AVLTreeNoderebalanceRight$this$_20, par$AVLTreeNoderebalanceRight$k$_16, old$AVLTreeNoderebalanceLR$0, old$AVLTreeNoderebalanceLR$1, old$AVLTreeNoderebalanceLR$2, old$AVLTreeNoderebalanceLR$3, old$AVLTreeNoderebalanceLR$4, par$AVLTreeNoderebalanceLR$this$_21, par$AVLTreeNoderebalanceLR$k$_17, old$AVLTreeNoderebalanceLL$0, old$AVLTreeNoderebalanceLL$1, old$AVLTreeNoderebalanceLL$2, old$AVLTreeNoderebalanceLL$3, old$AVLTreeNoderebalanceLL$4, old$AVLTreeNoderebalanceLL$5, par$AVLTreeNoderebalanceLL$this$_22, par$AVLTreeNoderebalanceLL$k$_18)
    fresh newK$_35
    constraining(newK$_35) {
      AVLTreeNodeinit$(n, newK$_35, k)
    }
    this$_3.AVLTreeroot$ := n
  } else {
    fresh newK$_36
    constraining(newK$_36) {
      r := AVLTreeNodeinsert$(this$_3.AVLTreeroot$, newK$_36, k)
    }
    this$_3.AVLTreeroot$ := r
  }
  this$_3.AVLTreekeys$ := this$_3.AVLTreeroot$.AVLTreeNodekeys$
  fold acc(AVLTreevalid$(this$_3), write)
}

method AVLTreeremove$(this$_4: Ref, k$_2: Perm, k: Int)
  requires this$_4 != null
  requires k$_2 > none
  requires write > k$_2
  requires acc(AVLTreevalid$(this$_4), write)
  requires acc(this$_4.AVLTreekeys$, 50 / 100)
  ensures acc(AVLTreevalid$(this$_4), write)
  ensures acc(this$_4.AVLTreekeys$, 50 / 100)
  ensures !(k in this$_4.AVLTreekeys$)
  ensures (forall j: Int :: true && j in old(this$_4.AVLTreekeys$) ==> j in this$_4.AVLTreekeys$ || (j == k))
  ensures (forall j: Int :: true && j in this$_4.AVLTreekeys$ ==> j in old(this$_4.AVLTreekeys$) && (j != k))
{
  var n$_2: Ref
  var a$_2: Ref
  var b$_2: Set[Ref]
  var c$_2: Set[Ref]
  var newK$_3: Perm
  var r: Ref
  unfold acc(AVLTreevalid$(this$_4), write)
  if (this$_4.AVLTreeroot$ == null) {
  } else {
    fresh newK$_3
    constraining(newK$_3) {
      r := AVLTreeNoderemove$(this$_4.AVLTreeroot$, newK$_3, k)
    }
    this$_4.AVLTreeroot$ := r
    this$_4.AVLTreekeys$ := (this$_4.AVLTreeroot$ == null ? Seq[Int]() : this$_4.AVLTreeroot$.AVLTreeNodekeys$)
  }
  fold acc(AVLTreevalid$(this$_4), write)
}

method AVLTreehas$(this$_5: Ref, k$_3: Perm, k: Int) returns (b: Bool)
  requires this$_5 != null
  requires k$_3 > none
  requires write > k$_3
  requires acc(AVLTreevalid$(this$_5), write)
  requires acc(this$_5.AVLTreekeys$, k$_3)
  ensures acc(AVLTreevalid$(this$_5), write)
  ensures acc(this$_5.AVLTreekeys$, k$_3)
  ensures b <==> k in this$_5.AVLTreekeys$
{
  var n$_3: Ref
  var a$_3: Ref
  var b$_3: Set[Ref]
  var c$_3: Set[Ref]
  var bb: Bool
  var newK$_2: Perm
  unfold acc(AVLTreevalid$(this$_5), write)
  if (this$_5.AVLTreeroot$ == null) {
    b := false
  } else {
    fresh newK$_2
    constraining(newK$_2) {
      bb := AVLTreeNodehas$(this$_5.AVLTreeroot$, newK$_2, k)
    }
    b := bb
  }
  fold acc(AVLTreevalid$(this$_5), write)
}

method AVLTreeNodeinit$(this$_8: Ref, k$_4: Perm, k: Int)
  requires this$_8 != null
  requires k$_4 > none
  requires write > k$_4
  requires acc(this$_8.AVLTreeNodekey$, 100 / 100)
  requires acc(this$_8.AVLTreeNodeheight$, 100 / 100)
  requires acc(this$_8.AVLTreeNodeleft$, 100 / 100)
  requires acc(this$_8.AVLTreeNoderight$, 100 / 100)
  requires acc(this$_8.AVLTreeNodekeys$, 100 / 100)
  requires acc(this$_8.AVLTreeNodebalanceFactor$, 100 / 100)
  ensures acc(AVLTreeNodevalid$(this$_8), write)
  ensures acc(this$_8.AVLTreeNodekeys$, 50 / 100)
  ensures acc(this$_8.AVLTreeNodeheight$, 50 / 100)
  ensures acc(this$_8.AVLTreeNodebalanceFactor$, 50 / 100)
  ensures this$_8.AVLTreeNodeheight$ == 1
  ensures this$_8.AVLTreeNodekeys$ == Seq(k)
  ensures this$_8.AVLTreeNodebalanceFactor$ == 0
  ensures k in this$_8.AVLTreeNodekeys$
{
  var n$_4: Ref
  var a$_4: Ref
  var b$_4: Set[Ref]
  var c$_4: Set[Ref]
  var newK$_21: Perm
  this$_8.AVLTreeNodeleft$ := null
  this$_8.AVLTreeNoderight$ := null
  this$_8.AVLTreeNodekey$ := k
  assert Seq(k)[0] == k
  fresh newK$_21
  constraining(newK$_21) {
    AVLTreeNodeclose$(this$_8, newK$_21)
  }
}

method AVLTreeNodeinsert$(this$_9: Ref, k$_5: Perm, k: Int) returns (r: Ref)
  requires this$_9 != null
  requires k$_5 > none
  requires write > k$_5
  requires acc(AVLTreeNodevalid$(this$_9), write)
  requires acc(this$_9.AVLTreeNodekeys$, 50 / 100)
  requires acc(this$_9.AVLTreeNodeheight$, 50 / 100)
  requires acc(this$_9.AVLTreeNodebalanceFactor$, 50 / 100)
  ensures r != null
  ensures acc(AVLTreeNodevalid$(r), write)
  ensures acc(r.AVLTreeNodekeys$, 50 / 100)
  ensures acc(r.AVLTreeNodeheight$, 50 / 100)
  ensures acc(r.AVLTreeNodebalanceFactor$, 50 / 100)
  ensures k in r.AVLTreeNodekeys$
  ensures (forall i: Int :: true && i in old(this$_9.AVLTreeNodekeys$) ==> i in r.AVLTreeNodekeys$)
  ensures (forall i: Int :: true && i in r.AVLTreeNodekeys$ ==> i in old(this$_9.AVLTreeNodekeys$) || (i == k))
  ensures k in old(this$_9.AVLTreeNodekeys$) ==> (r.AVLTreeNodekeys$ == old(this$_9.AVLTreeNodekeys$))
  ensures !(k in old(this$_9.AVLTreeNodekeys$)) ==> (|r.AVLTreeNodekeys$| == |old(this$_9.AVLTreeNodekeys$)| + 1)
  ensures (r.AVLTreeNodeheight$ == old(this$_9.AVLTreeNodeheight$)) || (r.AVLTreeNodeheight$ == old(this$_9.AVLTreeNodeheight$) + 1)
  ensures k in old(this$_9.AVLTreeNodekeys$) ==> (r.AVLTreeNodeheight$ == old(this$_9.AVLTreeNodeheight$))
{
  var n$_5: Ref
  var a$_5: Ref
  var b$_5: Set[Ref]
  var c$_5: Set[Ref]
  var newK$_4: Perm
  var nl: Ref
  var newK$_5: Perm
  var newK$_6: Perm
  var bf: Int
  var newK$_7: Perm
  var newK$_8: Perm
  var newK$_9: Perm
  var nr: Ref
  var newK$_10: Perm
  var newK$_11: Perm
  var newK$_12: Perm
  var newK$_13: Perm
  var newK$_14: Perm
  unfold acc(AVLTreeNodevalid$(this$_9), write)
  if (this$_9.AVLTreeNodekey$ == k) {
    r := this$_9
    assert k == Seq(this$_9.AVLTreeNodekey$)[0]
    fresh newK$_4
    constraining(newK$_4) {
      AVLTreeNodeclose$(r, newK$_4)
    }
  } elseif (k < this$_9.AVLTreeNodekey$) {
    if (this$_9.AVLTreeNodeleft$ == null) {
      n$_5 := new(old$methodPermission, joinable$, AVLTreeroot$, AVLTreekeys$, AVLTreeNodekey$, AVLTreeNodeheight$, AVLTreeNodeleft$, AVLTreeNoderight$, AVLTreeNodekeys$, AVLTreeNodebalanceFactor$, par$AVLTreeinit$this$_2, par$AVLTreeinit$k$, old$AVLTreeinsert$0, old$AVLTreeinsert$1, par$AVLTreeinsert$this$_3, par$AVLTreeinsert$k$_1, par$AVLTreeinsert$k, old$AVLTreeremove$0, old$AVLTreeremove$1, par$AVLTreeremove$this$_4, par$AVLTreeremove$k$_2, par$AVLTreeremove$k, par$AVLTreehas$this$_5, par$AVLTreehas$k$_3, par$AVLTreehas$k, par$AVLTreeNodeinit$this$_8, par$AVLTreeNodeinit$k$_4, par$AVLTreeNodeinit$k, old$AVLTreeNodeinsert$0, old$AVLTreeNodeinsert$1, old$AVLTreeNodeinsert$2, old$AVLTreeNodeinsert$3, old$AVLTreeNodeinsert$4, old$AVLTreeNodeinsert$5, old$AVLTreeNodeinsert$6, old$AVLTreeNodeinsert$7, old$AVLTreeNodeinsert$8, old$AVLTreeNodeinsert$9, par$AVLTreeNodeinsert$this$_9, par$AVLTreeNodeinsert$k$_5, par$AVLTreeNodeinsert$k, old$AVLTreeNoderemove$0, old$AVLTreeNoderemove$1, old$AVLTreeNoderemove$2, old$AVLTreeNoderemove$3, old$AVLTreeNoderemove$4, old$AVLTreeNoderemove$5, old$AVLTreeNoderemove$6, old$AVLTreeNoderemove$7, old$AVLTreeNoderemove$8, old$AVLTreeNoderemove$9, old$AVLTreeNoderemove$10, old$AVLTreeNoderemove$11, old$AVLTreeNoderemove$12, old$AVLTreeNoderemove$13, par$AVLTreeNoderemove$this$_10, par$AVLTreeNoderemove$k$_6, par$AVLTreeNoderemove$k, old$AVLTreeNodepruneMax$0, old$AVLTreeNodepruneMax$1, old$AVLTreeNodepruneMax$2, old$AVLTreeNodepruneMax$3, old$AVLTreeNodepruneMax$4, old$AVLTreeNodepruneMax$5, old$AVLTreeNodepruneMax$6, old$AVLTreeNodepruneMax$7, par$AVLTreeNodepruneMax$this$_11, par$AVLTreeNodepruneMax$k$_7, old$AVLTreeNodepruneMin$0, old$AVLTreeNodepruneMin$1, old$AVLTreeNodepruneMin$2, old$AVLTreeNodepruneMin$3, old$AVLTreeNodepruneMin$4, old$AVLTreeNodepruneMin$5, old$AVLTreeNodepruneMin$6, old$AVLTreeNodepruneMin$7, par$AVLTreeNodepruneMin$this$_12, par$AVLTreeNodepruneMin$k$_8, par$AVLTreeNodehas$this$_13, par$AVLTreeNodehas$k$_9, par$AVLTreeNodehas$k, par$AVLTreeNodegetBalanceFactor$this$_14, par$AVLTreeNodegetBalanceFactor$k$_10, par$AVLTreeNodegetBalanceFactorI$this$_15, par$AVLTreeNodegetBalanceFactorI$k$_11, old$AVLTreeNodeclose$0, old$AVLTreeNodeclose$1, old$AVLTreeNodeclose$2, old$AVLTreeNodeclose$3, old$AVLTreeNodeclose$4, old$AVLTreeNodeclose$5, old$AVLTreeNodeclose$6, old$AVLTreeNodeclose$7, old$AVLTreeNodeclose$8, old$AVLTreeNodeclose$9, old$AVLTreeNodeclose$10, old$AVLTreeNodeclose$11, old$AVLTreeNodeclose$12, old$AVLTreeNodeclose$13, old$AVLTreeNodeclose$14, old$AVLTreeNodeclose$15, old$AVLTreeNodeclose$16, par$AVLTreeNodeclose$this$_16, par$AVLTreeNodeclose$k$_12, old$AVLTreeNoderebalanceLeft$0, old$AVLTreeNoderebalanceLeft$1, old$AVLTreeNoderebalanceLeft$2, old$AVLTreeNoderebalanceLeft$3, old$AVLTreeNoderebalanceLeft$4, old$AVLTreeNoderebalanceLeft$5, par$AVLTreeNoderebalanceLeft$this$_17, par$AVLTreeNoderebalanceLeft$k$_13, old$AVLTreeNoderebalanceRL$0, old$AVLTreeNoderebalanceRL$1, old$AVLTreeNoderebalanceRL$2, old$AVLTreeNoderebalanceRL$3, old$AVLTreeNoderebalanceRL$4, par$AVLTreeNoderebalanceRL$this$_18, par$AVLTreeNoderebalanceRL$k$_14, old$AVLTreeNoderebalanceRR$0, old$AVLTreeNoderebalanceRR$1, old$AVLTreeNoderebalanceRR$2, old$AVLTreeNoderebalanceRR$3, old$AVLTreeNoderebalanceRR$4, old$AVLTreeNoderebalanceRR$5, par$AVLTreeNoderebalanceRR$this$_19, par$AVLTreeNoderebalanceRR$k$_15, old$AVLTreeNoderebalanceRight$0, old$AVLTreeNoderebalanceRight$1, old$AVLTreeNoderebalanceRight$2, old$AVLTreeNoderebalanceRight$3, old$AVLTreeNoderebalanceRight$4, old$AVLTreeNoderebalanceRight$5, par$AVLTreeNoderebalanceRight$this$_20, par$AVLTreeNoderebalanceRight$k$_16, old$AVLTreeNoderebalanceLR$0, old$AVLTreeNoderebalanceLR$1, old$AVLTreeNoderebalanceLR$2, old$AVLTreeNoderebalanceLR$3, old$AVLTreeNoderebalanceLR$4, par$AVLTreeNoderebalanceLR$this$_21, par$AVLTreeNoderebalanceLR$k$_17, old$AVLTreeNoderebalanceLL$0, old$AVLTreeNoderebalanceLL$1, old$AVLTreeNoderebalanceLL$2, old$AVLTreeNoderebalanceLL$3, old$AVLTreeNoderebalanceLL$4, old$AVLTreeNoderebalanceLL$5, par$AVLTreeNoderebalanceLL$this$_22, par$AVLTreeNoderebalanceLL$k$_18)
      nl := n$_5
      fresh newK$_5
      constraining(newK$_5) {
        AVLTreeNodeinit$(nl, newK$_5, k)
      }
    } else {
      fresh newK$_6
      constraining(newK$_6) {
        nl := AVLTreeNodeinsert$(this$_9.AVLTreeNodeleft$, newK$_6, k)
      }
    }
    this$_9.AVLTreeNodeleft$ := nl
    fresh newK$_7
    constraining(newK$_7) {
      bf := AVLTreeNodegetBalanceFactorI$(this$_9, newK$_7)
    }
    if (bf == 2) {
      fresh newK$_8
      constraining(newK$_8) {
        r := AVLTreeNoderebalanceLeft$(this$_9, newK$_8)
      }
    } else {
      r := this$_9
      fresh newK$_9
      constraining(newK$_9) {
        AVLTreeNodeclose$(r, newK$_9)
      }
    }
  } else {
    if (this$_9.AVLTreeNoderight$ == null) {
      n$_5 := new(old$methodPermission, joinable$, AVLTreeroot$, AVLTreekeys$, AVLTreeNodekey$, AVLTreeNodeheight$, AVLTreeNodeleft$, AVLTreeNoderight$, AVLTreeNodekeys$, AVLTreeNodebalanceFactor$, par$AVLTreeinit$this$_2, par$AVLTreeinit$k$, old$AVLTreeinsert$0, old$AVLTreeinsert$1, par$AVLTreeinsert$this$_3, par$AVLTreeinsert$k$_1, par$AVLTreeinsert$k, old$AVLTreeremove$0, old$AVLTreeremove$1, par$AVLTreeremove$this$_4, par$AVLTreeremove$k$_2, par$AVLTreeremove$k, par$AVLTreehas$this$_5, par$AVLTreehas$k$_3, par$AVLTreehas$k, par$AVLTreeNodeinit$this$_8, par$AVLTreeNodeinit$k$_4, par$AVLTreeNodeinit$k, old$AVLTreeNodeinsert$0, old$AVLTreeNodeinsert$1, old$AVLTreeNodeinsert$2, old$AVLTreeNodeinsert$3, old$AVLTreeNodeinsert$4, old$AVLTreeNodeinsert$5, old$AVLTreeNodeinsert$6, old$AVLTreeNodeinsert$7, old$AVLTreeNodeinsert$8, old$AVLTreeNodeinsert$9, par$AVLTreeNodeinsert$this$_9, par$AVLTreeNodeinsert$k$_5, par$AVLTreeNodeinsert$k, old$AVLTreeNoderemove$0, old$AVLTreeNoderemove$1, old$AVLTreeNoderemove$2, old$AVLTreeNoderemove$3, old$AVLTreeNoderemove$4, old$AVLTreeNoderemove$5, old$AVLTreeNoderemove$6, old$AVLTreeNoderemove$7, old$AVLTreeNoderemove$8, old$AVLTreeNoderemove$9, old$AVLTreeNoderemove$10, old$AVLTreeNoderemove$11, old$AVLTreeNoderemove$12, old$AVLTreeNoderemove$13, par$AVLTreeNoderemove$this$_10, par$AVLTreeNoderemove$k$_6, par$AVLTreeNoderemove$k, old$AVLTreeNodepruneMax$0, old$AVLTreeNodepruneMax$1, old$AVLTreeNodepruneMax$2, old$AVLTreeNodepruneMax$3, old$AVLTreeNodepruneMax$4, old$AVLTreeNodepruneMax$5, old$AVLTreeNodepruneMax$6, old$AVLTreeNodepruneMax$7, par$AVLTreeNodepruneMax$this$_11, par$AVLTreeNodepruneMax$k$_7, old$AVLTreeNodepruneMin$0, old$AVLTreeNodepruneMin$1, old$AVLTreeNodepruneMin$2, old$AVLTreeNodepruneMin$3, old$AVLTreeNodepruneMin$4, old$AVLTreeNodepruneMin$5, old$AVLTreeNodepruneMin$6, old$AVLTreeNodepruneMin$7, par$AVLTreeNodepruneMin$this$_12, par$AVLTreeNodepruneMin$k$_8, par$AVLTreeNodehas$this$_13, par$AVLTreeNodehas$k$_9, par$AVLTreeNodehas$k, par$AVLTreeNodegetBalanceFactor$this$_14, par$AVLTreeNodegetBalanceFactor$k$_10, par$AVLTreeNodegetBalanceFactorI$this$_15, par$AVLTreeNodegetBalanceFactorI$k$_11, old$AVLTreeNodeclose$0, old$AVLTreeNodeclose$1, old$AVLTreeNodeclose$2, old$AVLTreeNodeclose$3, old$AVLTreeNodeclose$4, old$AVLTreeNodeclose$5, old$AVLTreeNodeclose$6, old$AVLTreeNodeclose$7, old$AVLTreeNodeclose$8, old$AVLTreeNodeclose$9, old$AVLTreeNodeclose$10, old$AVLTreeNodeclose$11, old$AVLTreeNodeclose$12, old$AVLTreeNodeclose$13, old$AVLTreeNodeclose$14, old$AVLTreeNodeclose$15, old$AVLTreeNodeclose$16, par$AVLTreeNodeclose$this$_16, par$AVLTreeNodeclose$k$_12, old$AVLTreeNoderebalanceLeft$0, old$AVLTreeNoderebalanceLeft$1, old$AVLTreeNoderebalanceLeft$2, old$AVLTreeNoderebalanceLeft$3, old$AVLTreeNoderebalanceLeft$4, old$AVLTreeNoderebalanceLeft$5, par$AVLTreeNoderebalanceLeft$this$_17, par$AVLTreeNoderebalanceLeft$k$_13, old$AVLTreeNoderebalanceRL$0, old$AVLTreeNoderebalanceRL$1, old$AVLTreeNoderebalanceRL$2, old$AVLTreeNoderebalanceRL$3, old$AVLTreeNoderebalanceRL$4, par$AVLTreeNoderebalanceRL$this$_18, par$AVLTreeNoderebalanceRL$k$_14, old$AVLTreeNoderebalanceRR$0, old$AVLTreeNoderebalanceRR$1, old$AVLTreeNoderebalanceRR$2, old$AVLTreeNoderebalanceRR$3, old$AVLTreeNoderebalanceRR$4, old$AVLTreeNoderebalanceRR$5, par$AVLTreeNoderebalanceRR$this$_19, par$AVLTreeNoderebalanceRR$k$_15, old$AVLTreeNoderebalanceRight$0, old$AVLTreeNoderebalanceRight$1, old$AVLTreeNoderebalanceRight$2, old$AVLTreeNoderebalanceRight$3, old$AVLTreeNoderebalanceRight$4, old$AVLTreeNoderebalanceRight$5, par$AVLTreeNoderebalanceRight$this$_20, par$AVLTreeNoderebalanceRight$k$_16, old$AVLTreeNoderebalanceLR$0, old$AVLTreeNoderebalanceLR$1, old$AVLTreeNoderebalanceLR$2, old$AVLTreeNoderebalanceLR$3, old$AVLTreeNoderebalanceLR$4, par$AVLTreeNoderebalanceLR$this$_21, par$AVLTreeNoderebalanceLR$k$_17, old$AVLTreeNoderebalanceLL$0, old$AVLTreeNoderebalanceLL$1, old$AVLTreeNoderebalanceLL$2, old$AVLTreeNoderebalanceLL$3, old$AVLTreeNoderebalanceLL$4, old$AVLTreeNoderebalanceLL$5, par$AVLTreeNoderebalanceLL$this$_22, par$AVLTreeNoderebalanceLL$k$_18)
      nr := n$_5
      fresh newK$_10
      constraining(newK$_10) {
        AVLTreeNodeinit$(nr, newK$_10, k)
      }
    } else {
      fresh newK$_11
      constraining(newK$_11) {
        nr := AVLTreeNodeinsert$(this$_9.AVLTreeNoderight$, newK$_11, k)
      }
    }
    this$_9.AVLTreeNoderight$ := nr
    fresh newK$_12
    constraining(newK$_12) {
      bf := AVLTreeNodegetBalanceFactorI$(this$_9, newK$_12)
    }
    if (bf == 0 - 2) {
      fresh newK$_13
      constraining(newK$_13) {
        r := AVLTreeNoderebalanceRight$(this$_9, newK$_13)
      }
    } else {
      r := this$_9
      fresh newK$_14
      constraining(newK$_14) {
        AVLTreeNodeclose$(r, newK$_14)
      }
    }
  }
}

method AVLTreeNoderemove$(this$_10: Ref, k$_6: Perm, k: Int) returns (r: Ref)
  requires this$_10 != null
  requires k$_6 > none
  requires write > k$_6
  requires acc(AVLTreeNodevalid$(this$_10), write)
  requires acc(this$_10.AVLTreeNodekeys$, 50 / 100)
  requires acc(this$_10.AVLTreeNodeheight$, 50 / 100)
  requires acc(this$_10.AVLTreeNodebalanceFactor$, 50 / 100)
  ensures (old(this$_10.AVLTreeNodekeys$) == Seq(k)) ==> (r == null)
  ensures (old(this$_10.AVLTreeNodekeys$) != Seq(k)) ==> (r != null)
  ensures (r != null) ==> acc(AVLTreeNodevalid$(r), write)
  ensures (r != null) ==> acc(r.AVLTreeNodekeys$, 50 / 100)
  ensures (r != null) ==> acc(r.AVLTreeNodeheight$, 50 / 100)
  ensures (r != null) ==> acc(r.AVLTreeNodebalanceFactor$, 50 / 100)
    //:: UnexpectedOutput(postcondition.violated:assertion.false, /carbon/issue/18/)
  ensures (r != null) ==> !(k in r.AVLTreeNodekeys$)
  ensures (r != null) ==> (forall i: Int :: true && i in old(this$_10.AVLTreeNodekeys$) ==> i in r.AVLTreeNodekeys$ || (i == k))
  ensures (r != null) ==> (forall i: Int :: true && i in r.AVLTreeNodekeys$ ==> i in old(this$_10.AVLTreeNodekeys$) && (i != k))
  ensures !(k in old(this$_10.AVLTreeNodekeys$)) ==> (r != null)
  ensures !(k in old(this$_10.AVLTreeNodekeys$)) ==> (r.AVLTreeNodekeys$ == old(this$_10.AVLTreeNodekeys$))
  ensures (r != null) ==> k in old(this$_10.AVLTreeNodekeys$) ==> (|r.AVLTreeNodekeys$| == |old(this$_10.AVLTreeNodekeys$)| - 1)
  ensures (old(this$_10.AVLTreeNodeheight$) > 1) ==> (r != null)
  ensures (r != null) ==> (r.AVLTreeNodeheight$ == old(this$_10.AVLTreeNodeheight$)) || (r.AVLTreeNodeheight$ + 1 == old(this$_10.AVLTreeNodeheight$))
  ensures !(k in old(this$_10.AVLTreeNodekeys$)) ==> (r.AVLTreeNodeheight$ == old(this$_10.AVLTreeNodeheight$))
{
  var n$_6: Ref
  var a$_6: Ref
  var b$_6: Set[Ref]
  var c$_6: Set[Ref]
  var bf: Int
  var nl: Ref
  var nr: Ref
  var newK$_39: Perm
  var newK$_40: Perm
  var newK$_41: Perm
  var newK$_42: Perm
  var newK$_43: Perm
  var newK$_44: Perm
  var newK$_45: Perm
  var newK$_46: Perm
  var newK$_47: Perm
  var newK$_48: Perm
  var newK$_49: Perm
  var newK$_50: Perm
  var newK$_51: Perm
  var newK$_52: Perm
  unfold acc(AVLTreeNodevalid$(this$_10), write)
  if (this$_10.AVLTreeNodekey$ == k) {
    if ((this$_10.AVLTreeNodeleft$ == null) || (this$_10.AVLTreeNoderight$ == null)) {
      assert (this$_10.AVLTreeNoderight$ != null) ==> (unfolding acc(AVLTreeNodevalid$(this$_10.AVLTreeNoderight$), write) in this$_10.AVLTreeNoderight$.AVLTreeNodekeys$ != Seq[Int]())
      assert (this$_10.AVLTreeNodeleft$ != null) ==> (unfolding acc(AVLTreeNodevalid$(this$_10.AVLTreeNodeleft$), write) in this$_10.AVLTreeNodeleft$.AVLTreeNodekeys$ != Seq[Int]())
      if (this$_10.AVLTreeNodeleft$ == null) {
        r := this$_10.AVLTreeNoderight$
      } else {
        r := this$_10.AVLTreeNodeleft$
      }
    } else {
      nl := this$_10.AVLTreeNodeleft$
      nr := this$_10.AVLTreeNoderight$
      fresh newK$_39
      constraining(newK$_39) {
        bf := AVLTreeNodegetBalanceFactorI$(this$_10, newK$_39)
      }
      if (bf > 0) {
        fresh newK$_40
        constraining(newK$_40) {
          nl, r := AVLTreeNodepruneMax$(this$_10.AVLTreeNodeleft$, newK$_40)
        }
      } else {
        fresh newK$_41
        constraining(newK$_41) {
          nr, r := AVLTreeNodepruneMin$(this$_10.AVLTreeNoderight$, newK$_41)
        }
      }
      unfold acc(AVLTreeNodevalid$(r), write)
      r.AVLTreeNodeleft$ := nl
      r.AVLTreeNoderight$ := nr
      fresh newK$_42
      constraining(newK$_42) {
        //:: UnexpectedOutput(call.precondition:assertion.false, /silicon/issue/90/)
        //:: UnexpectedOutput(call.precondition:assertion.false, /carbon/issue/18/)
        AVLTreeNodeclose$(r, newK$_42)
      }
    }
  } elseif (k < this$_10.AVLTreeNodekey$) {
    if (this$_10.AVLTreeNodeleft$ != null) {
      fresh newK$_43
      constraining(newK$_43) {
        nl := AVLTreeNoderemove$(this$_10.AVLTreeNodeleft$, newK$_43, k)
      }
      this$_10.AVLTreeNodeleft$ := nl
      fresh newK$_44
      constraining(newK$_44) {
        bf := AVLTreeNodegetBalanceFactorI$(this$_10, newK$_44)
      }
      if (bf == 0 - 2) {
        fresh newK$_45
        constraining(newK$_45) {
          r := AVLTreeNoderebalanceRight$(this$_10, newK$_45)
        }
      } else {
        fresh newK$_46
        constraining(newK$_46) {
          AVLTreeNodeclose$(this$_10, newK$_46)
        }
        r := this$_10
      }
    } else {
      r := this$_10
      fresh newK$_47
      constraining(newK$_47) {
        AVLTreeNodeclose$(r, newK$_47)
      }
    }
  } elseif (this$_10.AVLTreeNoderight$ != null) {
    fresh newK$_48
    constraining(newK$_48) {
      nr := AVLTreeNoderemove$(this$_10.AVLTreeNoderight$, newK$_48, k)
    }
    this$_10.AVLTreeNoderight$ := nr
    fresh newK$_49
    constraining(newK$_49) {
      bf := AVLTreeNodegetBalanceFactorI$(this$_10, newK$_49)
    }
    if (bf == 2) {
      fresh newK$_50
      constraining(newK$_50) {
        r := AVLTreeNoderebalanceLeft$(this$_10, newK$_50)
      }
    } else {
      r := this$_10
      fresh newK$_51
      constraining(newK$_51) {
        AVLTreeNodeclose$(r, newK$_51)
      }
    }
  } else {
    r := this$_10
    fresh newK$_52
    constraining(newK$_52) {
      AVLTreeNodeclose$(r, newK$_52)
    }
  }
}

method AVLTreeNodepruneMax$(this$_11: Ref, k$_7: Perm) returns (r: Ref, m: Ref)
  requires this$_11 != null
  requires k$_7 > none
  requires write > k$_7
  requires acc(AVLTreeNodevalid$(this$_11), write)
  requires acc(this$_11.AVLTreeNodekeys$, 50 / 100)
  requires acc(this$_11.AVLTreeNodeheight$, 50 / 100)
  requires acc(this$_11.AVLTreeNodebalanceFactor$, 50 / 100)
  ensures (r != null) ==> acc(AVLTreeNodevalid$(r), write)
  ensures (r != null) ==> acc(r.AVLTreeNodekeys$, 50 / 100)
  ensures (r != null) ==> acc(r.AVLTreeNodeheight$, 50 / 100)
  ensures (r != null) ==> acc(r.AVLTreeNodebalanceFactor$, 50 / 100)
  ensures (r != null) ==> (r.AVLTreeNodeheight$ == old(this$_11.AVLTreeNodeheight$)) || (r.AVLTreeNodeheight$ + 1 == old(this$_11.AVLTreeNodeheight$))
  ensures (r != null) ==> (|r.AVLTreeNodekeys$| + 1 == |old(this$_11.AVLTreeNodekeys$)|)
  ensures (old(this$_11.AVLTreeNodeheight$) > 1) ==> (r != null)
  ensures (old(this$_11.AVLTreeNodeheight$) == 1) ==> (r == null)
  ensures (old(this$_11.AVLTreeNodeheight$) == (r == null ? 0 : r.AVLTreeNodeheight$)) || (old(this$_11.AVLTreeNodeheight$) == (r == null ? 0 : r.AVLTreeNodeheight$) + 1)
  ensures m != null
  ensures acc(AVLTreeNodevalid$(m), write)
  ensures acc(m.AVLTreeNodekeys$, 50 / 100)
  ensures acc(m.AVLTreeNodeheight$, 50 / 100)
  ensures acc(m.AVLTreeNodebalanceFactor$, 50 / 100)
  ensures m.AVLTreeNodeheight$ == 1
  ensures |m.AVLTreeNodekeys$| == 1
  ensures (r == null ? Seq[Int]() : r.AVLTreeNodekeys$) ++ m.AVLTreeNodekeys$ == old(this$_11.AVLTreeNodekeys$)
  ensures (r != null) ==> (forall k: Int :: true && k in r.AVLTreeNodekeys$ ==> (k < m.AVLTreeNodekeys$[0]))
{
  var n$_7: Ref
  var a$_7: Ref
  var b$_7: Set[Ref]
  var c$_7: Set[Ref]
  var newK$_30: Perm
  var nr: Ref
  var newK$_31: Perm
  var bf: Int
  var newK$_32: Perm
  var newK$_33: Perm
  var newK$_34: Perm
  unfold acc(AVLTreeNodevalid$(this$_11), write)
  if (this$_11.AVLTreeNoderight$ == null) {
    r := this$_11.AVLTreeNodeleft$
    this$_11.AVLTreeNodeleft$ := null
    fresh newK$_30
    constraining(newK$_30) {
      AVLTreeNodeclose$(this$_11, newK$_30)
    }
    m := this$_11
    assert (r != null) ==> (forall k: Int :: true && k in r.AVLTreeNodekeys$ ==> (k < m.AVLTreeNodekeys$[0]))
  } else {
    fresh newK$_31
    constraining(newK$_31) {
      nr, m := AVLTreeNodepruneMax$(this$_11.AVLTreeNoderight$, newK$_31)
    }
    this$_11.AVLTreeNoderight$ := nr
    fresh newK$_32
    constraining(newK$_32) {
      bf := AVLTreeNodegetBalanceFactorI$(this$_11, newK$_32)
    }
    if (bf == 2) {
      fresh newK$_33
      constraining(newK$_33) {
        //:: UnexpectedOutput(call.precondition:assertion.false, /silicon/issue/90/)
        //:: UnexpectedOutput(call.precondition:assertion.false, /carbon/issue/18/)
        r := AVLTreeNoderebalanceLeft$(this$_11, newK$_33)
      }
    } else {
      fresh newK$_34
      constraining(newK$_34) {
        //:: UnexpectedOutput(call.precondition:assertion.false, /carbon/issue/18/)
        AVLTreeNodeclose$(this$_11, newK$_34)
      }
      r := this$_11
    }
    //:: UnexpectedOutput(assert.failed:assertion.false, /carbon/issue/18/)
    assert (r != null) ==> (forall k: Int :: true && k in r.AVLTreeNodekeys$ ==> (k < m.AVLTreeNodekeys$[0]))
  }
}

method AVLTreeNodepruneMin$(this$_12: Ref, k$_8: Perm) returns (r: Ref, m: Ref)
  requires this$_12 != null
  requires k$_8 > none
  requires write > k$_8
  requires acc(AVLTreeNodevalid$(this$_12), write)
  requires acc(this$_12.AVLTreeNodekeys$, 50 / 100)
  requires acc(this$_12.AVLTreeNodeheight$, 50 / 100)
  requires acc(this$_12.AVLTreeNodebalanceFactor$, 50 / 100)
  ensures (r != null) ==> acc(AVLTreeNodevalid$(r), write)
  ensures (r != null) ==> acc(r.AVLTreeNodekeys$, 50 / 100)
  ensures (r != null) ==> acc(r.AVLTreeNodeheight$, 50 / 100)
  ensures (r != null) ==> acc(r.AVLTreeNodebalanceFactor$, 50 / 100)
  ensures (r != null) ==> (r.AVLTreeNodeheight$ == old(this$_12.AVLTreeNodeheight$)) || (r.AVLTreeNodeheight$ == old(this$_12.AVLTreeNodeheight$) - 1)
  ensures (r != null) ==> (|r.AVLTreeNodekeys$| + 1 == |old(this$_12.AVLTreeNodekeys$)|)
  ensures (old(this$_12.AVLTreeNodeheight$) > 1) ==> (r != null)
  ensures (old(this$_12.AVLTreeNodeheight$) == 1) ==> (r == null)
  ensures (old(this$_12.AVLTreeNodeheight$) == (r == null ? 0 : r.AVLTreeNodeheight$)) || (old(this$_12.AVLTreeNodeheight$) == (r == null ? 0 : r.AVLTreeNodeheight$) + 1)
  ensures m != null
  ensures acc(AVLTreeNodevalid$(m), write)
  ensures acc(m.AVLTreeNodekeys$, 50 / 100)
  ensures acc(m.AVLTreeNodeheight$, 50 / 100)
  ensures acc(m.AVLTreeNodebalanceFactor$, 50 / 100)
  ensures m.AVLTreeNodeheight$ == 1
  ensures |m.AVLTreeNodekeys$| == 1
  ensures m.AVLTreeNodekeys$ ++ (r == null ? Seq[Int]() : r.AVLTreeNodekeys$) == old(this$_12.AVLTreeNodekeys$)
  ensures (r != null) ==> (forall k: Int :: true && k in r.AVLTreeNodekeys$ ==> (m.AVLTreeNodekeys$[0] < k))
{
  var n$_8: Ref
  var a$_8: Ref
  var b$_8: Set[Ref]
  var c$_8: Set[Ref]
  var newK$_53: Perm
  var nl: Ref
  var newK$_54: Perm
  var bf: Int
  var newK$_55: Perm
  var newK$_56: Perm
  var newK$_57: Perm
  unfold acc(AVLTreeNodevalid$(this$_12), write)
  if (this$_12.AVLTreeNodeleft$ == null) {
    r := this$_12.AVLTreeNoderight$
    this$_12.AVLTreeNoderight$ := null
    fresh newK$_53
    constraining(newK$_53) {
      AVLTreeNodeclose$(this$_12, newK$_53)
    }
    m := this$_12
    assert (r != null) ==> (r.AVLTreeNodeheight$ == old(this$_12.AVLTreeNodeheight$)) || (r.AVLTreeNodeheight$ == old(this$_12.AVLTreeNodeheight$) - 1)
    assert (r != null) ==> (forall k: Int :: true && k in r.AVLTreeNodekeys$ ==> (m.AVLTreeNodekeys$[0] < k))
  } else {
    fresh newK$_54
    constraining(newK$_54) {
      nl, m := AVLTreeNodepruneMin$(this$_12.AVLTreeNodeleft$, newK$_54)
    }
    this$_12.AVLTreeNodeleft$ := nl
    fresh newK$_55
    constraining(newK$_55) {
      bf := AVLTreeNodegetBalanceFactorI$(this$_12, newK$_55)
    }
    if (bf == 0 - 2) {
      fresh newK$_56
      constraining(newK$_56) {
        //:: UnexpectedOutput(call.precondition:assertion.false, /silicon/issue/90/)
        //:: UnexpectedOutput(call.precondition:assertion.false, /carbon/issue/18/)
        r := AVLTreeNoderebalanceRight$(this$_12, newK$_56)
      }
      assert (r != null) ==> (r.AVLTreeNodeheight$ == old(this$_12.AVLTreeNodeheight$)) || (r.AVLTreeNodeheight$ == old(this$_12.AVLTreeNodeheight$) - 1)
    } else {
      fresh newK$_57
      constraining(newK$_57) {
        //:: UnexpectedOutput(call.precondition:assertion.false, /carbon/issue/18/)
        AVLTreeNodeclose$(this$_12, newK$_57)
      }
      r := this$_12
      assert (r != null) ==> (r.AVLTreeNodeheight$ == old(this$_12.AVLTreeNodeheight$)) || (r.AVLTreeNodeheight$ == old(this$_12.AVLTreeNodeheight$) - 1)
    }
    //:: UnexpectedOutput(assert.failed:assertion.false, /carbon/issue/18/)
    assert (r != null) ==> (forall k: Int :: true && k in r.AVLTreeNodekeys$ ==> (m.AVLTreeNodekeys$[0] < k))
  }
}

method AVLTreeNodehas$(this$_13: Ref, k$_9: Perm, k: Int) returns (b: Bool)
  requires this$_13 != null
  requires k$_9 > none
  requires write > k$_9
  requires acc(AVLTreeNodevalid$(this$_13), write)
  requires acc(this$_13.AVLTreeNodekeys$, k$_9)
  ensures acc(AVLTreeNodevalid$(this$_13), write)
  ensures acc(this$_13.AVLTreeNodekeys$, k$_9)
  ensures b <==> k in this$_13.AVLTreeNodekeys$
{
  var n$_9: Ref
  var a$_9: Ref
  var b$_9: Set[Ref]
  var c$_9: Set[Ref]
  var newK$_28: Perm
  var newK$_29: Perm
  unfold acc(AVLTreeNodevalid$(this$_13), write)
  if (k == this$_13.AVLTreeNodekey$) {
    b := true
    assert Seq(this$_13.AVLTreeNodekey$)[0] == k
  } elseif (k < this$_13.AVLTreeNodekey$) {
    if (this$_13.AVLTreeNodeleft$ != null) {
      fresh newK$_28
      constraining(newK$_28) {
        b := AVLTreeNodehas$(this$_13.AVLTreeNodeleft$, newK$_28, k)
      }
    } else {
      b := false
    }
  } elseif (this$_13.AVLTreeNoderight$ != null) {
    fresh newK$_29
    constraining(newK$_29) {
      b := AVLTreeNodehas$(this$_13.AVLTreeNoderight$, newK$_29, k)
    }
  } else {
    b := false
  }
  fold acc(AVLTreeNodevalid$(this$_13), write)
}

method AVLTreeNodegetBalanceFactor$(this$_14: Ref, k$_10: Perm) returns (bf: Int)
  requires this$_14 != null
  requires k$_10 > none
  requires write > k$_10
  requires acc(AVLTreeNodevalid$(this$_14), write)
  requires acc(this$_14.AVLTreeNodebalanceFactor$, k$_10)
  ensures acc(AVLTreeNodevalid$(this$_14), write)
  ensures acc(this$_14.AVLTreeNodebalanceFactor$, k$_10)
  ensures bf == this$_14.AVLTreeNodebalanceFactor$
  ensures (unfolding acc(AVLTreeNodevalid$(this$_14), write) in (bf > 0) ==> (this$_14.AVLTreeNodeleft$ != null))
  ensures (unfolding acc(AVLTreeNodevalid$(this$_14), write) in (bf < 0) ==> (this$_14.AVLTreeNoderight$ != null))
{
  var n$_10: Ref
  var a$_10: Ref
  var b$_10: Set[Ref]
  var c$_10: Set[Ref]
  var lh: Int
  var rh: Int
  unfold acc(AVLTreeNodevalid$(this$_14), write)
  lh := (this$_14.AVLTreeNodeleft$ == null ? 0 : this$_14.AVLTreeNodeleft$.AVLTreeNodeheight$)
  rh := (this$_14.AVLTreeNoderight$ == null ? 0 : this$_14.AVLTreeNoderight$.AVLTreeNodeheight$)
  bf := lh - rh
  fold acc(AVLTreeNodevalid$(this$_14), write)
}

method AVLTreeNodegetBalanceFactorI$(this$_15: Ref, k$_11: Perm) returns (bf: Int)
  requires this$_15 != null
  requires k$_11 > none
  requires write > k$_11
  requires acc(this$_15.AVLTreeNodeleft$, k$_11)
  requires (this$_15.AVLTreeNodeleft$ != null) ==> acc(AVLTreeNodevalid$(this$_15.AVLTreeNodeleft$), write)
  requires (this$_15.AVLTreeNodeleft$ != null) ==> acc(this$_15.AVLTreeNodeleft$.AVLTreeNodeheight$, k$_11)
  requires acc(this$_15.AVLTreeNoderight$, k$_11)
  requires (this$_15.AVLTreeNoderight$ != null) ==> acc(AVLTreeNodevalid$(this$_15.AVLTreeNoderight$), write)
  requires (this$_15.AVLTreeNoderight$ != null) ==> acc(this$_15.AVLTreeNoderight$.AVLTreeNodeheight$, k$_11)
  ensures acc(this$_15.AVLTreeNodeleft$, k$_11)
  ensures (this$_15.AVLTreeNodeleft$ != null) ==> acc(AVLTreeNodevalid$(this$_15.AVLTreeNodeleft$), write)
  ensures (this$_15.AVLTreeNodeleft$ != null) ==> acc(this$_15.AVLTreeNodeleft$.AVLTreeNodeheight$, k$_11)
  ensures acc(this$_15.AVLTreeNoderight$, k$_11)
  ensures (this$_15.AVLTreeNoderight$ != null) ==> acc(AVLTreeNodevalid$(this$_15.AVLTreeNoderight$), write)
  ensures (this$_15.AVLTreeNoderight$ != null) ==> acc(this$_15.AVLTreeNoderight$.AVLTreeNodeheight$, k$_11)
  ensures bf == (this$_15.AVLTreeNodeleft$ == null ? 0 : this$_15.AVLTreeNodeleft$.AVLTreeNodeheight$) - (this$_15.AVLTreeNoderight$ == null ? 0 : this$_15.AVLTreeNoderight$.AVLTreeNodeheight$)
  ensures (bf > 0) ==> (this$_15.AVLTreeNodeleft$ != null)
  ensures (bf < 0) ==> (this$_15.AVLTreeNoderight$ != null)
{
  var n$_11: Ref
  var a$_11: Ref
  var b$_11: Set[Ref]
  var c$_11: Set[Ref]
  var lh: Int
  var rh: Int
  lh := (this$_15.AVLTreeNodeleft$ == null ? 0 : this$_15.AVLTreeNodeleft$.AVLTreeNodeheight$)
  rh := (this$_15.AVLTreeNoderight$ == null ? 0 : this$_15.AVLTreeNoderight$.AVLTreeNodeheight$)
  bf := lh - rh
  assert (this$_15.AVLTreeNoderight$ != null) ==> (unfolding acc(AVLTreeNodevalid$(this$_15.AVLTreeNoderight$), write) in this$_15.AVLTreeNoderight$.AVLTreeNodeheight$ > 0)
  assert (this$_15.AVLTreeNodeleft$ != null) ==> (unfolding acc(AVLTreeNodevalid$(this$_15.AVLTreeNodeleft$), write) in this$_15.AVLTreeNodeleft$.AVLTreeNodeheight$ > 0)
  assert lh >= 0
  assert rh >= 0
}

method AVLTreeNodeclose$(this$_16: Ref, k$_12: Perm)
  requires this$_16 != null
  requires k$_12 > none
  requires write > k$_12
  requires acc(this$_16.AVLTreeNodekey$, 100 / 100)
  requires acc(this$_16.AVLTreeNodeheight$, 100 / 100)
  requires acc(this$_16.AVLTreeNodeleft$, 100 / 100)
  requires acc(this$_16.AVLTreeNoderight$, 100 / 100)
  requires acc(this$_16.AVLTreeNodekeys$, 100 / 100)
  requires acc(this$_16.AVLTreeNodebalanceFactor$, 100 / 100)
  requires (this$_16.AVLTreeNodeleft$ != null) ==> acc(AVLTreeNodevalid$(this$_16.AVLTreeNodeleft$), write)
  requires (this$_16.AVLTreeNodeleft$ != null) ==> acc(this$_16.AVLTreeNodeleft$.AVLTreeNodeheight$, 50 / 100)
  requires (this$_16.AVLTreeNodeleft$ != null) ==> acc(this$_16.AVLTreeNodeleft$.AVLTreeNodekeys$, 50 / 100)
  requires (this$_16.AVLTreeNodeleft$ != null) ==> acc(this$_16.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$, 50 / 100)
  requires (this$_16.AVLTreeNodeleft$ != null) ==> (forall k: Int :: true && k in this$_16.AVLTreeNodeleft$.AVLTreeNodekeys$ ==> (k < this$_16.AVLTreeNodekey$))
  requires (this$_16.AVLTreeNoderight$ != null) ==> acc(AVLTreeNodevalid$(this$_16.AVLTreeNoderight$), write)
  requires (this$_16.AVLTreeNoderight$ != null) ==> acc(this$_16.AVLTreeNoderight$.AVLTreeNodeheight$, 50 / 100)
  requires (this$_16.AVLTreeNoderight$ != null) ==> acc(this$_16.AVLTreeNoderight$.AVLTreeNodekeys$, 50 / 100)
  requires (this$_16.AVLTreeNoderight$ != null) ==> acc(this$_16.AVLTreeNoderight$.AVLTreeNodebalanceFactor$, 50 / 100)
  requires (this$_16.AVLTreeNoderight$ != null) ==> (forall k: Int :: true && k in this$_16.AVLTreeNoderight$.AVLTreeNodekeys$ ==> (this$_16.AVLTreeNodekey$ < k))
  requires (this$_16.AVLTreeNodeleft$ == null ? 0 : this$_16.AVLTreeNodeleft$.AVLTreeNodeheight$) - (this$_16.AVLTreeNoderight$ == null ? 0 : this$_16.AVLTreeNoderight$.AVLTreeNodeheight$) <= 1
  requires (this$_16.AVLTreeNodeleft$ == null ? 0 : this$_16.AVLTreeNodeleft$.AVLTreeNodeheight$) - (this$_16.AVLTreeNoderight$ == null ? 0 : this$_16.AVLTreeNoderight$.AVLTreeNodeheight$) >= 0 - 1
  ensures acc(AVLTreeNodevalid$(this$_16), write)
  ensures acc(this$_16.AVLTreeNodeheight$, 50 / 100)
  ensures acc(this$_16.AVLTreeNodekeys$, 50 / 100)
  ensures acc(this$_16.AVLTreeNodebalanceFactor$, 50 / 100)
  ensures this$_16.AVLTreeNodekeys$ == (old(this$_16.AVLTreeNodeleft$) == null ? Seq[Int]() : old(this$_16.AVLTreeNodeleft$.AVLTreeNodekeys$)) ++ Seq(old(this$_16.AVLTreeNodekey$)) ++ (old(this$_16.AVLTreeNoderight$) == null ? Seq[Int]() : old(this$_16.AVLTreeNoderight$.AVLTreeNodekeys$))
  ensures this$_16.AVLTreeNodeheight$ == ((old(this$_16.AVLTreeNodeleft$) == null ? 0 : old(this$_16.AVLTreeNodeleft$.AVLTreeNodeheight$)) > (old(this$_16.AVLTreeNoderight$) == null ? 0 : old(this$_16.AVLTreeNoderight$.AVLTreeNodeheight$)) ? (old(this$_16.AVLTreeNodeleft$) == null ? 0 : old(this$_16.AVLTreeNodeleft$.AVLTreeNodeheight$)) + 1 : (old(this$_16.AVLTreeNoderight$) == null ? 0 : old(this$_16.AVLTreeNoderight$.AVLTreeNodeheight$)) + 1)
  ensures this$_16.AVLTreeNodebalanceFactor$ == (old(this$_16.AVLTreeNodeleft$) == null ? 0 : old(this$_16.AVLTreeNodeleft$.AVLTreeNodeheight$)) - (old(this$_16.AVLTreeNoderight$) == null ? 0 : old(this$_16.AVLTreeNoderight$.AVLTreeNodeheight$))
{
  var n$_12: Ref
  var a$_12: Ref
  var b$_12: Set[Ref]
  var c$_12: Set[Ref]
  var lh: Int
  var rh: Int
  lh := (this$_16.AVLTreeNodeleft$ == null ? 0 : this$_16.AVLTreeNodeleft$.AVLTreeNodeheight$)
  rh := (this$_16.AVLTreeNoderight$ == null ? 0 : this$_16.AVLTreeNoderight$.AVLTreeNodeheight$)
  assert (this$_16.AVLTreeNodeleft$ != null) ==> (unfolding acc(AVLTreeNodevalid$(this$_16.AVLTreeNodeleft$), write) in this$_16.AVLTreeNodeleft$.AVLTreeNodeheight$ > 0)
  assert (this$_16.AVLTreeNoderight$ != null) ==> (unfolding acc(AVLTreeNodevalid$(this$_16.AVLTreeNoderight$), write) in this$_16.AVLTreeNoderight$.AVLTreeNodeheight$ > 0)
  this$_16.AVLTreeNodeheight$ := ((this$_16.AVLTreeNodeleft$ == null ? 0 : this$_16.AVLTreeNodeleft$.AVLTreeNodeheight$) > (this$_16.AVLTreeNoderight$ == null ? 0 : this$_16.AVLTreeNoderight$.AVLTreeNodeheight$) ? (this$_16.AVLTreeNodeleft$ == null ? 0 : this$_16.AVLTreeNodeleft$.AVLTreeNodeheight$) + 1 : (this$_16.AVLTreeNoderight$ == null ? 0 : this$_16.AVLTreeNoderight$.AVLTreeNodeheight$) + 1)
  this$_16.AVLTreeNodebalanceFactor$ := (this$_16.AVLTreeNodeleft$ == null ? 0 : this$_16.AVLTreeNodeleft$.AVLTreeNodeheight$) - (this$_16.AVLTreeNoderight$ == null ? 0 : this$_16.AVLTreeNoderight$.AVLTreeNodeheight$)
  this$_16.AVLTreeNodekeys$ := (this$_16.AVLTreeNodeleft$ == null ? Seq[Int]() : this$_16.AVLTreeNodeleft$.AVLTreeNodekeys$) ++ Seq(this$_16.AVLTreeNodekey$) ++ (this$_16.AVLTreeNoderight$ == null ? Seq[Int]() : this$_16.AVLTreeNoderight$.AVLTreeNodekeys$)
  assert Seq(this$_16.AVLTreeNodekey$)[0] == this$_16.AVLTreeNodekey$
  fold acc(AVLTreeNodevalid$(this$_16), write)
}

method AVLTreeNoderebalanceLeft$(this$_17: Ref, k$_13: Perm) returns (r: Ref)
  requires this$_17 != null
  requires k$_13 > none
  requires write > k$_13
  requires acc(this$_17.AVLTreeNodekey$, 100 / 100)
  requires acc(this$_17.AVLTreeNodeheight$, 100 / 100)
  requires acc(this$_17.AVLTreeNodeleft$, 100 / 100)
  requires acc(this$_17.AVLTreeNoderight$, 100 / 100)
  requires acc(this$_17.AVLTreeNodekeys$, 100 / 100)
  requires acc(this$_17.AVLTreeNodebalanceFactor$, 100 / 100)
  requires this$_17.AVLTreeNodeleft$ != null
  requires acc(AVLTreeNodevalid$(this$_17.AVLTreeNodeleft$), write)
  requires acc(this$_17.AVLTreeNodeleft$.AVLTreeNodeheight$, 50 / 100)
  requires acc(this$_17.AVLTreeNodeleft$.AVLTreeNodekeys$, 50 / 100)
  requires acc(this$_17.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$, 50 / 100)
  requires (forall k: Int :: true && k in this$_17.AVLTreeNodeleft$.AVLTreeNodekeys$ ==> (k < this$_17.AVLTreeNodekey$))
  requires (this$_17.AVLTreeNoderight$ != null) ==> acc(AVLTreeNodevalid$(this$_17.AVLTreeNoderight$), write)
  requires (this$_17.AVLTreeNoderight$ != null) ==> acc(this$_17.AVLTreeNoderight$.AVLTreeNodeheight$, 50 / 100)
  requires (this$_17.AVLTreeNoderight$ != null) ==> acc(this$_17.AVLTreeNoderight$.AVLTreeNodekeys$, 50 / 100)
  requires (this$_17.AVLTreeNoderight$ != null) ==> acc(this$_17.AVLTreeNoderight$.AVLTreeNodebalanceFactor$, 50 / 100)
  requires (this$_17.AVLTreeNoderight$ != null) ==> (forall k: Int :: true && k in this$_17.AVLTreeNoderight$.AVLTreeNodekeys$ ==> (this$_17.AVLTreeNodekey$ < k))
  requires this$_17.AVLTreeNodeleft$.AVLTreeNodeheight$ - (this$_17.AVLTreeNoderight$ == null ? 0 : this$_17.AVLTreeNoderight$.AVLTreeNodeheight$) == 2
  ensures r != null
  ensures acc(AVLTreeNodevalid$(r), write)
  ensures acc(r.AVLTreeNodeheight$, 50 / 100)
  ensures acc(r.AVLTreeNodekeys$, 50 / 100)
  ensures acc(r.AVLTreeNodebalanceFactor$, 50 / 100)
  ensures (r.AVLTreeNodeheight$ == old(this$_17.AVLTreeNodeleft$.AVLTreeNodeheight$)) || (r.AVLTreeNodeheight$ == old(this$_17.AVLTreeNodeleft$.AVLTreeNodeheight$) + 1)
  ensures r.AVLTreeNodekeys$ == old(this$_17.AVLTreeNodeleft$.AVLTreeNodekeys$) ++ Seq(old(this$_17.AVLTreeNodekey$)) ++ (old(this$_17.AVLTreeNoderight$) == null ? Seq[Int]() : old(this$_17.AVLTreeNoderight$.AVLTreeNodekeys$))
{
  var n$_13: Ref
  var a$_13: Ref
  var b$_13: Set[Ref]
  var c$_13: Set[Ref]
  var lbf: Int
  var newK$_18: Perm
  var newK$_19: Perm
  var newK$_20: Perm
  fresh newK$_18
  constraining(newK$_18) {
    lbf := AVLTreeNodegetBalanceFactor$(this$_17.AVLTreeNodeleft$, newK$_18)
  }
  if (lbf < 0) {
    assert (unfolding acc(AVLTreeNodevalid$(this$_17.AVLTreeNodeleft$), write) in lbf == 0 - 1)
    fresh newK$_19
    constraining(newK$_19) {
      r := AVLTreeNoderebalanceRL$(this$_17, newK$_19)
    }
  } else {
    fresh newK$_20
    constraining(newK$_20) {
      r := AVLTreeNoderebalanceRR$(this$_17, newK$_20)
    }
  }
}

method AVLTreeNoderebalanceRL$(this$_18: Ref, k$_14: Perm) returns (r: Ref)
  requires this$_18 != null
  requires k$_14 > none
  requires write > k$_14
  requires acc(this$_18.AVLTreeNodekey$, 100 / 100)
  requires acc(this$_18.AVLTreeNodeheight$, 100 / 100)
  requires acc(this$_18.AVLTreeNodeleft$, 100 / 100)
  requires acc(this$_18.AVLTreeNoderight$, 100 / 100)
  requires acc(this$_18.AVLTreeNodekeys$, 100 / 100)
  requires acc(this$_18.AVLTreeNodebalanceFactor$, 100 / 100)
  requires this$_18.AVLTreeNodeleft$ != null
  requires acc(AVLTreeNodevalid$(this$_18.AVLTreeNodeleft$), write)
  requires acc(this$_18.AVLTreeNodeleft$.AVLTreeNodeheight$, 50 / 100)
  requires acc(this$_18.AVLTreeNodeleft$.AVLTreeNodekeys$, 50 / 100)
  requires acc(this$_18.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$, 50 / 100)
  requires (forall k: Int :: true && k in this$_18.AVLTreeNodeleft$.AVLTreeNodekeys$ ==> (k < this$_18.AVLTreeNodekey$))
  requires (this$_18.AVLTreeNoderight$ != null) ==> acc(AVLTreeNodevalid$(this$_18.AVLTreeNoderight$), write)
  requires (this$_18.AVLTreeNoderight$ != null) ==> acc(this$_18.AVLTreeNoderight$.AVLTreeNodeheight$, 50 / 100)
  requires (this$_18.AVLTreeNoderight$ != null) ==> acc(this$_18.AVLTreeNoderight$.AVLTreeNodekeys$, 50 / 100)
  requires (this$_18.AVLTreeNoderight$ != null) ==> acc(this$_18.AVLTreeNoderight$.AVLTreeNodebalanceFactor$, 50 / 100)
  requires (this$_18.AVLTreeNoderight$ != null) ==> (forall k: Int :: true && k in this$_18.AVLTreeNoderight$.AVLTreeNodekeys$ ==> (this$_18.AVLTreeNodekey$ < k))
  requires (unfolding acc(AVLTreeNodevalid$(this$_18.AVLTreeNodeleft$), write) in this$_18.AVLTreeNodeleft$.AVLTreeNoderight$ != null)
  requires this$_18.AVLTreeNodeleft$.AVLTreeNodeheight$ - (this$_18.AVLTreeNoderight$ == null ? 0 : this$_18.AVLTreeNoderight$.AVLTreeNodeheight$) == 2
  requires this$_18.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$ == 0 - 1
  ensures r != null
  ensures acc(AVLTreeNodevalid$(r), write)
  ensures acc(r.AVLTreeNodeheight$, 50 / 100)
  ensures acc(r.AVLTreeNodekeys$, 50 / 100)
  ensures acc(r.AVLTreeNodebalanceFactor$, 50 / 100)
  ensures r.AVLTreeNodeheight$ == old(this$_18.AVLTreeNodeleft$.AVLTreeNodeheight$)
  ensures r.AVLTreeNodekeys$ == old(this$_18.AVLTreeNodeleft$.AVLTreeNodekeys$) ++ Seq(old(this$_18.AVLTreeNodekey$)) ++ (old(this$_18.AVLTreeNoderight$) == null ? Seq[Int]() : old(this$_18.AVLTreeNoderight$.AVLTreeNodekeys$))
{
  var n$_14: Ref
  var a$_14: Ref
  var b$_14: Set[Ref]
  var c$_14: Set[Ref]
  var newK$_25: Perm
  var newK$_26: Perm
  var newK$_27: Perm
  assert (forall k: Int :: true && k in this$_18.AVLTreeNodeleft$.AVLTreeNodekeys$ ==> (k < this$_18.AVLTreeNodekey$))
  unfold acc(AVLTreeNodevalid$(this$_18.AVLTreeNodeleft$), write)
  r := this$_18.AVLTreeNodeleft$.AVLTreeNoderight$
  assert (forall k: Int :: true && k in r.AVLTreeNodekeys$ ==> (k < this$_18.AVLTreeNodekey$))
  unfold acc(AVLTreeNodevalid$(r), write)
  assert (r.AVLTreeNoderight$ != null) ==> (forall k: Int :: true && k in r.AVLTreeNoderight$.AVLTreeNodekeys$ ==> (k < this$_18.AVLTreeNodekey$))
  this$_18.AVLTreeNodeleft$.AVLTreeNoderight$ := r.AVLTreeNodeleft$
  fresh newK$_25
  constraining(newK$_25) {
    AVLTreeNodeclose$(this$_18.AVLTreeNodeleft$, newK$_25)
  }
  r.AVLTreeNodeleft$ := this$_18.AVLTreeNodeleft$
  this$_18.AVLTreeNodeleft$ := r.AVLTreeNoderight$
  assert (this$_18.AVLTreeNodeleft$ != null) ==> (forall k: Int :: true && k in this$_18.AVLTreeNodeleft$.AVLTreeNodekeys$ ==> (k < this$_18.AVLTreeNodekey$))
  fresh newK$_26
  constraining(newK$_26) {
    AVLTreeNodeclose$(this$_18, newK$_26)
  }
  r.AVLTreeNoderight$ := this$_18
  fresh newK$_27
  constraining(newK$_27) {
    AVLTreeNodeclose$(r, newK$_27)
  }
}

method AVLTreeNoderebalanceRR$(this$_19: Ref, k$_15: Perm) returns (r: Ref)
  requires this$_19 != null
  requires k$_15 > none
  requires write > k$_15
  requires acc(this$_19.AVLTreeNodekey$, 100 / 100)
  requires acc(this$_19.AVLTreeNodeheight$, 100 / 100)
  requires acc(this$_19.AVLTreeNodeleft$, 100 / 100)
  requires acc(this$_19.AVLTreeNoderight$, 100 / 100)
  requires acc(this$_19.AVLTreeNodekeys$, 100 / 100)
  requires acc(this$_19.AVLTreeNodebalanceFactor$, 100 / 100)
  requires this$_19.AVLTreeNodeleft$ != null
  requires acc(AVLTreeNodevalid$(this$_19.AVLTreeNodeleft$), write)
  requires acc(this$_19.AVLTreeNodeleft$.AVLTreeNodeheight$, 50 / 100)
  requires acc(this$_19.AVLTreeNodeleft$.AVLTreeNodekeys$, 50 / 100)
  requires acc(this$_19.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$, 50 / 100)
  requires (forall k: Int :: true && k in this$_19.AVLTreeNodeleft$.AVLTreeNodekeys$ ==> (k < this$_19.AVLTreeNodekey$))
  requires (this$_19.AVLTreeNoderight$ != null) ==> acc(AVLTreeNodevalid$(this$_19.AVLTreeNoderight$), write)
  requires (this$_19.AVLTreeNoderight$ != null) ==> acc(this$_19.AVLTreeNoderight$.AVLTreeNodeheight$, 50 / 100)
  requires (this$_19.AVLTreeNoderight$ != null) ==> acc(this$_19.AVLTreeNoderight$.AVLTreeNodekeys$, 50 / 100)
  requires (this$_19.AVLTreeNoderight$ != null) ==> acc(this$_19.AVLTreeNoderight$.AVLTreeNodebalanceFactor$, 50 / 100)
  requires (this$_19.AVLTreeNoderight$ != null) ==> (forall k: Int :: true && k in this$_19.AVLTreeNoderight$.AVLTreeNodekeys$ ==> (this$_19.AVLTreeNodekey$ < k))
  requires this$_19.AVLTreeNodeleft$.AVLTreeNodeheight$ - (this$_19.AVLTreeNoderight$ == null ? 0 : this$_19.AVLTreeNoderight$.AVLTreeNodeheight$) == 2
  requires this$_19.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$ >= 0
  ensures r != null
  ensures acc(AVLTreeNodevalid$(r), write)
  ensures acc(r.AVLTreeNodeheight$, 50 / 100)
  ensures acc(r.AVLTreeNodekeys$, 50 / 100)
  ensures acc(r.AVLTreeNodebalanceFactor$, 50 / 100)
  ensures (r.AVLTreeNodeheight$ == old(this$_19.AVLTreeNodeleft$.AVLTreeNodeheight$)) || (r.AVLTreeNodeheight$ == old(this$_19.AVLTreeNodeleft$.AVLTreeNodeheight$) + 1)
  ensures r.AVLTreeNodekeys$ == old(this$_19.AVLTreeNodeleft$.AVLTreeNodekeys$) ++ Seq(old(this$_19.AVLTreeNodekey$)) ++ (old(this$_19.AVLTreeNoderight$) == null ? Seq[Int]() : old(this$_19.AVLTreeNoderight$.AVLTreeNodekeys$))
{
  var n$_15: Ref
  var a$_15: Ref
  var b$_15: Set[Ref]
  var c$_15: Set[Ref]
  var newK$: Perm
  var newK$_1: Perm
  unfold acc(AVLTreeNodevalid$(this$_19.AVLTreeNodeleft$), write)
  r := this$_19.AVLTreeNodeleft$
  this$_19.AVLTreeNodeleft$ := r.AVLTreeNoderight$
  fresh newK$
  constraining(newK$) {
    AVLTreeNodeclose$(this$_19, newK$)
  }
  r.AVLTreeNoderight$ := this$_19
  fresh newK$_1
  constraining(newK$_1) {
    AVLTreeNodeclose$(r, newK$_1)
  }
}

method AVLTreeNoderebalanceRight$(this$_20: Ref, k$_16: Perm) returns (r: Ref)
  requires this$_20 != null
  requires k$_16 > none
  requires write > k$_16
  requires acc(this$_20.AVLTreeNodekey$, 100 / 100)
  requires acc(this$_20.AVLTreeNodeheight$, 100 / 100)
  requires acc(this$_20.AVLTreeNodeleft$, 100 / 100)
  requires acc(this$_20.AVLTreeNoderight$, 100 / 100)
  requires acc(this$_20.AVLTreeNodekeys$, 100 / 100)
  requires acc(this$_20.AVLTreeNodebalanceFactor$, 100 / 100)
  requires (this$_20.AVLTreeNodeleft$ != null) ==> acc(AVLTreeNodevalid$(this$_20.AVLTreeNodeleft$), write)
  requires (this$_20.AVLTreeNodeleft$ != null) ==> acc(this$_20.AVLTreeNodeleft$.AVLTreeNodeheight$, 50 / 100)
  requires (this$_20.AVLTreeNodeleft$ != null) ==> acc(this$_20.AVLTreeNodeleft$.AVLTreeNodekeys$, 50 / 100)
  requires (this$_20.AVLTreeNodeleft$ != null) ==> acc(this$_20.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$, 50 / 100)
  requires (this$_20.AVLTreeNodeleft$ != null) ==> (forall k: Int :: true && k in this$_20.AVLTreeNodeleft$.AVLTreeNodekeys$ ==> (k < this$_20.AVLTreeNodekey$))
  requires this$_20.AVLTreeNoderight$ != null
  requires acc(AVLTreeNodevalid$(this$_20.AVLTreeNoderight$), write)
  requires acc(this$_20.AVLTreeNoderight$.AVLTreeNodeheight$, 50 / 100)
  requires acc(this$_20.AVLTreeNoderight$.AVLTreeNodekeys$, 50 / 100)
  requires acc(this$_20.AVLTreeNoderight$.AVLTreeNodebalanceFactor$, 50 / 100)
  requires (forall k: Int :: true && k in this$_20.AVLTreeNoderight$.AVLTreeNodekeys$ ==> (this$_20.AVLTreeNodekey$ < k))
  requires (this$_20.AVLTreeNodeleft$ == null ? 0 : this$_20.AVLTreeNodeleft$.AVLTreeNodeheight$) - this$_20.AVLTreeNoderight$.AVLTreeNodeheight$ == 0 - 2
  ensures r != null
  ensures acc(AVLTreeNodevalid$(r), write)
  ensures acc(r.AVLTreeNodeheight$, 50 / 100)
  ensures acc(r.AVLTreeNodekeys$, 50 / 100)
  ensures acc(r.AVLTreeNodebalanceFactor$, 50 / 100)
  ensures (r.AVLTreeNodeheight$ == old(this$_20.AVLTreeNoderight$.AVLTreeNodeheight$)) || (r.AVLTreeNodeheight$ == old(this$_20.AVLTreeNoderight$.AVLTreeNodeheight$) + 1)
  ensures r.AVLTreeNodekeys$ == (old(this$_20.AVLTreeNodeleft$) == null ? Seq[Int]() : old(this$_20.AVLTreeNodeleft$.AVLTreeNodekeys$)) ++ Seq(old(this$_20.AVLTreeNodekey$)) ++ old(this$_20.AVLTreeNoderight$.AVLTreeNodekeys$)
{
  var n$_16: Ref
  var a$_16: Ref
  var b$_16: Set[Ref]
  var c$_16: Set[Ref]
  var rbf: Int
  var newK$_22: Perm
  var newK$_23: Perm
  var newK$_24: Perm
  fresh newK$_22
  constraining(newK$_22) {
    rbf := AVLTreeNodegetBalanceFactor$(this$_20.AVLTreeNoderight$, newK$_22)
  }
  if (rbf > 0) {
    assert (unfolding acc(AVLTreeNodevalid$(this$_20.AVLTreeNoderight$), write) in rbf == 1)
    fresh newK$_23
    constraining(newK$_23) {
      r := AVLTreeNoderebalanceLR$(this$_20, newK$_23)
    }
  } else {
    fresh newK$_24
    constraining(newK$_24) {
      r := AVLTreeNoderebalanceLL$(this$_20, newK$_24)
    }
  }
}

method AVLTreeNoderebalanceLR$(this$_21: Ref, k$_17: Perm) returns (r: Ref)
  requires this$_21 != null
  requires k$_17 > none
  requires write > k$_17
  requires acc(this$_21.AVLTreeNodekey$, 100 / 100)
  requires acc(this$_21.AVLTreeNodeheight$, 100 / 100)
  requires acc(this$_21.AVLTreeNodeleft$, 100 / 100)
  requires acc(this$_21.AVLTreeNoderight$, 100 / 100)
  requires acc(this$_21.AVLTreeNodekeys$, 100 / 100)
  requires acc(this$_21.AVLTreeNodebalanceFactor$, 100 / 100)
  requires (this$_21.AVLTreeNodeleft$ != null) ==> acc(AVLTreeNodevalid$(this$_21.AVLTreeNodeleft$), write)
  requires (this$_21.AVLTreeNodeleft$ != null) ==> acc(this$_21.AVLTreeNodeleft$.AVLTreeNodeheight$, 50 / 100)
  requires (this$_21.AVLTreeNodeleft$ != null) ==> acc(this$_21.AVLTreeNodeleft$.AVLTreeNodekeys$, 50 / 100)
  requires (this$_21.AVLTreeNodeleft$ != null) ==> acc(this$_21.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$, 50 / 100)
  requires (this$_21.AVLTreeNodeleft$ != null) ==> (forall k: Int :: true && k in this$_21.AVLTreeNodeleft$.AVLTreeNodekeys$ ==> (k < this$_21.AVLTreeNodekey$))
  requires this$_21.AVLTreeNoderight$ != null
  requires acc(AVLTreeNodevalid$(this$_21.AVLTreeNoderight$), write)
  requires acc(this$_21.AVLTreeNoderight$.AVLTreeNodeheight$, 50 / 100)
  requires acc(this$_21.AVLTreeNoderight$.AVLTreeNodekeys$, 50 / 100)
  requires acc(this$_21.AVLTreeNoderight$.AVLTreeNodebalanceFactor$, 50 / 100)
  requires (forall k: Int :: true && k in this$_21.AVLTreeNoderight$.AVLTreeNodekeys$ ==> (this$_21.AVLTreeNodekey$ < k))
  requires (unfolding acc(AVLTreeNodevalid$(this$_21.AVLTreeNoderight$), write) in this$_21.AVLTreeNoderight$.AVLTreeNodeleft$ != null)
  requires (this$_21.AVLTreeNodeleft$ == null ? 0 : this$_21.AVLTreeNodeleft$.AVLTreeNodeheight$) - this$_21.AVLTreeNoderight$.AVLTreeNodeheight$ == 0 - 2
  requires this$_21.AVLTreeNoderight$.AVLTreeNodebalanceFactor$ == 1
  ensures r != null
  ensures acc(AVLTreeNodevalid$(r), write)
  ensures acc(r.AVLTreeNodeheight$, 50 / 100)
  ensures acc(r.AVLTreeNodekeys$, 50 / 100)
  ensures acc(r.AVLTreeNodebalanceFactor$, 50 / 100)
  ensures r.AVLTreeNodeheight$ == old(this$_21.AVLTreeNoderight$.AVLTreeNodeheight$)
  ensures r.AVLTreeNodekeys$ == (old(this$_21.AVLTreeNodeleft$) == null ? Seq[Int]() : old(this$_21.AVLTreeNodeleft$.AVLTreeNodekeys$)) ++ Seq(old(this$_21.AVLTreeNodekey$)) ++ old(this$_21.AVLTreeNoderight$.AVLTreeNodekeys$)
{
  var n$_17: Ref
  var a$_17: Ref
  var b$_17: Set[Ref]
  var c$_17: Set[Ref]
  var newK$_15: Perm
  var newK$_16: Perm
  var newK$_17: Perm
  assert (forall k: Int :: true && k in this$_21.AVLTreeNoderight$.AVLTreeNodekeys$ ==> (this$_21.AVLTreeNodekey$ < k))
  unfold acc(AVLTreeNodevalid$(this$_21.AVLTreeNoderight$), write)
  r := this$_21.AVLTreeNoderight$.AVLTreeNodeleft$
  assert (forall k: Int :: true && k in r.AVLTreeNodekeys$ ==> (this$_21.AVLTreeNodekey$ < k))
  unfold acc(AVLTreeNodevalid$(r), write)
  assert (r.AVLTreeNodeleft$ != null) ==> (forall k: Int :: true && k in r.AVLTreeNodeleft$.AVLTreeNodekeys$ ==> (this$_21.AVLTreeNodekey$ < k))
  this$_21.AVLTreeNoderight$.AVLTreeNodeleft$ := r.AVLTreeNoderight$
  fresh newK$_15
  constraining(newK$_15) {
    AVLTreeNodeclose$(this$_21.AVLTreeNoderight$, newK$_15)
  }
  r.AVLTreeNoderight$ := this$_21.AVLTreeNoderight$
  this$_21.AVLTreeNoderight$ := r.AVLTreeNodeleft$
  assert (this$_21.AVLTreeNoderight$ != null) ==> (forall k: Int :: true && k in this$_21.AVLTreeNoderight$.AVLTreeNodekeys$ ==> (this$_21.AVLTreeNodekey$ < k))
  fresh newK$_16
  constraining(newK$_16) {
    AVLTreeNodeclose$(this$_21, newK$_16)
  }
  r.AVLTreeNodeleft$ := this$_21
  fresh newK$_17
  constraining(newK$_17) {
    AVLTreeNodeclose$(r, newK$_17)
  }
}

method AVLTreeNoderebalanceLL$(this$_22: Ref, k$_18: Perm) returns (r: Ref)
  requires this$_22 != null
  requires k$_18 > none
  requires write > k$_18
  requires acc(this$_22.AVLTreeNodekey$, 100 / 100)
  requires acc(this$_22.AVLTreeNodeheight$, 100 / 100)
  requires acc(this$_22.AVLTreeNodeleft$, 100 / 100)
  requires acc(this$_22.AVLTreeNoderight$, 100 / 100)
  requires acc(this$_22.AVLTreeNodekeys$, 100 / 100)
  requires acc(this$_22.AVLTreeNodebalanceFactor$, 100 / 100)
  requires (this$_22.AVLTreeNodeleft$ != null) ==> acc(AVLTreeNodevalid$(this$_22.AVLTreeNodeleft$), write)
  requires (this$_22.AVLTreeNodeleft$ != null) ==> acc(this$_22.AVLTreeNodeleft$.AVLTreeNodeheight$, 50 / 100)
  requires (this$_22.AVLTreeNodeleft$ != null) ==> acc(this$_22.AVLTreeNodeleft$.AVLTreeNodekeys$, 50 / 100)
  requires (this$_22.AVLTreeNodeleft$ != null) ==> acc(this$_22.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$, 50 / 100)
  requires (this$_22.AVLTreeNodeleft$ != null) ==> (forall k: Int :: true && k in this$_22.AVLTreeNodeleft$.AVLTreeNodekeys$ ==> (k < this$_22.AVLTreeNodekey$))
  requires this$_22.AVLTreeNoderight$ != null
  requires acc(AVLTreeNodevalid$(this$_22.AVLTreeNoderight$), write)
  requires acc(this$_22.AVLTreeNoderight$.AVLTreeNodeheight$, 50 / 100)
  requires acc(this$_22.AVLTreeNoderight$.AVLTreeNodekeys$, 50 / 100)
  requires acc(this$_22.AVLTreeNoderight$.AVLTreeNodebalanceFactor$, 50 / 100)
  requires (forall k: Int :: true && k in this$_22.AVLTreeNoderight$.AVLTreeNodekeys$ ==> (this$_22.AVLTreeNodekey$ < k))
  requires (this$_22.AVLTreeNodeleft$ == null ? 0 : this$_22.AVLTreeNodeleft$.AVLTreeNodeheight$) - this$_22.AVLTreeNoderight$.AVLTreeNodeheight$ == 0 - 2
  requires this$_22.AVLTreeNoderight$.AVLTreeNodebalanceFactor$ <= 0
  ensures r != null
  ensures acc(AVLTreeNodevalid$(r), write)
  ensures acc(r.AVLTreeNodeheight$, 50 / 100)
  ensures acc(r.AVLTreeNodekeys$, 50 / 100)
  ensures acc(r.AVLTreeNodebalanceFactor$, 50 / 100)
  ensures (r.AVLTreeNodeheight$ == old(this$_22.AVLTreeNoderight$.AVLTreeNodeheight$)) || (r.AVLTreeNodeheight$ == old(this$_22.AVLTreeNoderight$.AVLTreeNodeheight$) + 1)
  ensures r.AVLTreeNodekeys$ == (old(this$_22.AVLTreeNodeleft$) == null ? Seq[Int]() : old(this$_22.AVLTreeNodeleft$.AVLTreeNodekeys$)) ++ Seq(old(this$_22.AVLTreeNodekey$)) ++ old(this$_22.AVLTreeNoderight$.AVLTreeNodekeys$)
{
  var n$_18: Ref
  var a$_18: Ref
  var b$_18: Set[Ref]
  var c$_18: Set[Ref]
  var newK$_37: Perm
  var newK$_38: Perm
  unfold acc(AVLTreeNodevalid$(this$_22.AVLTreeNoderight$), write)
  r := this$_22.AVLTreeNoderight$
  this$_22.AVLTreeNoderight$ := r.AVLTreeNodeleft$
  fresh newK$_37
  constraining(newK$_37) {
    AVLTreeNodeclose$(this$_22, newK$_37)
  }
  r.AVLTreeNodeleft$ := this$_22
  fresh newK$_38
  constraining(newK$_38) {
    AVLTreeNodeclose$(r, newK$_38)
  }
}
